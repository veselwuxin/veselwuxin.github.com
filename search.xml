<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>PE加载过程</title>
    <url>/2020/03/02/PE%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>前面对PE结构都有了一定的了解，现在就到了对PE应用的阶段了</p>
<a id="more"></a>

<p>一个EXE文件中可能会有多个PE结构，而当文件在被打开的时候，是经过了一系列的操作才运行的，这里就来说一下PE的加载过程，只有对PE的加载过程足够的了解，才能在里面进行一系列的操作。</p>
<h1 id="PE加载过程"><a href="#PE加载过程" class="headerlink" title="PE加载过程"></a>PE加载过程</h1><p>首先会将PE文件的全部内容拷到一个内存中，可以将它称为文件缓冲区FileBuffer，此时内容跟文件原本的内容是完全一致的，接着会对它进行一个拉伸的操作，此时文件对其方式就改变了，内容大部分都是一样的，有一部分内容是会被更改的，但是对齐方式是完全改变了的，可以将它称为文件映像ImageBuffer，这样的情况下也还是不能运行的，只是更加接近运行时候的状态了。</p>
<p>此次的练习就是模拟这个过程，然后再将ImageBuffer转会到FileBuffer，再进行存盘，因为在后面我们可以对其中的内容进行修改，就需要进行这样的操作。</p>
<p><img src="/2020/03/02/PE%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/01.png" alt></p>
<h1 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h1><p>代码：<a href="https://github.com/veselwuxin/code.seclibs.com/blob/master/pe/PE_Load_test.cpp" target="_blank" rel="noopener">GitHub</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">(FILE* ptFile)</span> </span>&#123;</span><br><span class="line">	fseek(ptFile, <span class="number">0</span>, SEEK_END);</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span> = ftell(ptFile);</span><br><span class="line">	fseek(ptFile, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FileBufferTOImageBuffer</span><span class="params">(LPSTR pFileBuffer, <span class="keyword">int</span> FileSize)</span> </span>&#123;</span><br><span class="line">	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer;</span><br><span class="line">	PIMAGE_FILE_HEADER pFileHeader = (PIMAGE_FILE_HEADER)(pFileBuffer + (DWORD)pDosHeader-&gt;e_lfanew + <span class="number">4</span>);</span><br><span class="line">	PIMAGE_OPTIONAL_HEADER pOptionalHeader = (PIMAGE_OPTIONAL_HEADER)((DWORD)pFileHeader + <span class="keyword">sizeof</span>(_IMAGE_FILE_HEADER));</span><br><span class="line">	<span class="keyword">int</span> ImageSize = pOptionalHeader-&gt;SizeOfImage;</span><br><span class="line">	<span class="keyword">char</span>* ImageBuffer = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(ImageSize);</span><br><span class="line">	<span class="built_in">memset</span>(ImageBuffer, <span class="number">0</span>, ImageSize);</span><br><span class="line">	<span class="built_in">memcpy</span>(ImageBuffer, pFileBuffer, pOptionalHeader-&gt;SizeOfHeaders);</span><br><span class="line"></span><br><span class="line">	PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pOptionalHeader + pFileHeader-&gt;SizeOfOptionalHeader);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pFileHeader-&gt;NumberOfSections; i++) &#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(ImageBuffer + pSectionHeader-&gt;VirtualAddress, pFileBuffer + pSectionHeader-&gt;PointerToRawData, (pSectionHeader-&gt;SizeOfRawData));</span><br><span class="line">		pSectionHeader++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span>* NewFileBuffer = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(FileSize);</span><br><span class="line">	<span class="built_in">memset</span>(NewFileBuffer, <span class="number">0</span>, FileSize);</span><br><span class="line">	</span><br><span class="line">	PIMAGE_DOS_HEADER ImageDosHeader = (PIMAGE_DOS_HEADER)ImageBuffer;</span><br><span class="line">	PIMAGE_FILE_HEADER ImageFileHeader = (PIMAGE_FILE_HEADER)(ImageBuffer + (DWORD)ImageDosHeader-&gt;e_lfanew + <span class="number">4</span>);</span><br><span class="line">	PIMAGE_OPTIONAL_HEADER ImageOptionalHeader = (PIMAGE_OPTIONAL_HEADER)((DWORD)ImageFileHeader + <span class="keyword">sizeof</span>(_IMAGE_FILE_HEADER));</span><br><span class="line">	PIMAGE_SECTION_HEADER ImageSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)ImageOptionalHeader + ImageFileHeader-&gt;SizeOfOptionalHeader);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(NewFileBuffer, ImageBuffer, ImageOptionalHeader-&gt;SizeOfHeaders);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ImageFileHeader-&gt;NumberOfSections; i++) &#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(NewFileBuffer + ImageSectionHeader-&gt;PointerToRawData, ImageBuffer + ImageSectionHeader-&gt;VirtualAddress, ImageSectionHeader-&gt;SizeOfRawData);</span><br><span class="line">		ImageSectionHeader++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FILE* NewFile = fopen(<span class="string">"C:\\Users\\veselwuxin\\Desktop\\wtest1.exe"</span>, <span class="string">"wb"</span>);</span><br><span class="line">	fwrite(NewFileBuffer, <span class="number">1</span>, FileSize, NewFile);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(ImageBuffer);</span><br><span class="line">	ImageBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">free</span>(NewFileBuffer);</span><br><span class="line">	NewFileBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	NewFile = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	FILE* tFile = fopen(<span class="string">"C:\\Users\\veselwuxin\\Desktop\\wtest.exe"</span>, <span class="string">"rb"</span>);</span><br><span class="line">	<span class="keyword">if</span> (tFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"file open failed\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> FileSize = GetSize(tFile);</span><br><span class="line">	<span class="keyword">char</span>* FileBuffer = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * FileSize);</span><br><span class="line">	<span class="keyword">if</span> (!FileBuffer) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Alloc FileBuffer Failed\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(FileBuffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * FileSize);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> FreadSize = fread(FileBuffer, <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * FileSize, tFile);</span><br><span class="line">	<span class="keyword">if</span> (FreadSize != <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * FileSize) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"FileBuffer Write Failed\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"FileBuffer address:%p\n"</span>, FileBuffer);</span><br><span class="line"></span><br><span class="line">	FileBufferTOImageBuffer(FileBuffer, FileSize);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(FileBuffer);</span><br><span class="line">	FileBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	tFile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然整体代码不够精炼，也已经达到了学习阶段对过程的理解</p>
]]></content>
      <categories>
        <category>PE</category>
      </categories>
  </entry>
  <entry>
    <title>PE节表说明</title>
    <url>/2020/03/02/PE%E8%8A%82%E8%A1%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>上一篇文章解析了PE结构的几个头，这次把节表的结构也写了进来。</p>
<a id="more"></a>

<p>节表储存着所有节的相关信息，节表就相当于是目录，告诉你某一个节在哪块，它的相关信息什么。</p>
<h1 id="节表的结构及意义"><a href="#节表的结构及意义" class="headerlink" title="节表的结构及意义"></a>节表的结构及意义</h1><p>先直接给出节表的结构体方便后面的学习</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SIZEOF_SHORT_NAME              8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfRawData;</span><br><span class="line">    DWORD   PointerToRawData;</span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>

<ul>
<li>Name，可以看到第一个数组为名字，长度为8个字节，这里需要注意的是它并不是必须遵循 \0 结尾的规定，如果不以 \0 结尾，系统会自动截取8位进行处理。</li>
<li>Misc，这是一个联合体，因为它们都是DWORD的长度，所以不需要过于区分，我们常用的都是VirtualSize，它是在没有对齐前的真实长度。</li>
<li>VirtualAddress，它是在内存中的偏移地址。</li>
<li>SizeOfRawData，在文件中对其后的长度。</li>
<li>PointerToRawData，在文件中的偏移地址。</li>
<li>PointerToRelocations、PointerToLinenumbers、NumberOfRelocations、NumberOfLinenumbers 这四个主要是在调试的时候去使用的，这里暂时先忽略掉。</li>
<li>Characteristics，节的属性，由于节的名字是可以随便修改的，并不是说它叫<code>.date</code>，它就是数据段，我们需要通过属性来对其内容进行一个简要的判断。</li>
</ul>
<p>通过上面的结构可以很清楚的得到节表的长度为40个字节。</p>
<h1 id="节表解析代码"><a href="#节表解析代码" class="headerlink" title="节表解析代码"></a>节表解析代码</h1><p>这里没有单独将节表的解析拉出来写，而是在上一篇的基础上增加的，所以这里将是PE头和节表的整体代码</p>
<p>代码：<a href="https://github.com/veselwuxin/code.seclibs.com/blob/master/pe/Read_Section_Header.cpp" target="_blank" rel="noopener">GitHub</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">filesize</span><span class="params">(FILE* file)</span> </span>&#123;</span><br><span class="line">	fseek(file, <span class="number">0</span>, SEEK_END);</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span> = ftell(file);</span><br><span class="line">	fseek(file, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DOS_Header</span><span class="params">(LPSTR pFileBuffer)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"----------DOSHeader----------\n"</span>);</span><br><span class="line">	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// *(PWORD)pDosHeader != IMAGE_DOS_SIGNATURE</span></span><br><span class="line">	<span class="keyword">if</span> ((WORD)pDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"DOSHeader failed:MZ"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  e_magic:%x\n"</span>, (WORD)pDosHeader-&gt;e_magic);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  e_lfanew:%08x\n"</span>, (DWORD)pDosHeader-&gt;e_lfanew);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> pDosHeader-&gt;e_lfanew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NT_Header</span><span class="params">(LPSTR pFileBuffer, <span class="keyword">int</span> NT_addr)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"----------NTHeader----------\n"</span>);</span><br><span class="line">	PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pFileBuffer + NT_addr);</span><br><span class="line">	<span class="keyword">if</span> ((WORD)pNtHeader-&gt;Signature != IMAGE_NT_SIGNATURE) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"NTHeader failed:NT"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Signature:%08x\n"</span>, (DWORD)pNtHeader-&gt;Signature);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"----------FileHeader----------\n"</span>);</span><br><span class="line">	PIMAGE_FILE_HEADER FileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNtHeader + <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  Machine:%04x\n"</span>, FileHeader-&gt;Machine);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  NumberOfSections:%04x\n"</span>, FileHeader-&gt;NumberOfSections);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"TimeDateStamp:%08x\n"</span>, FileHeader-&gt;TimeDateStamp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  SizeOfOptionalHeader:%04x\n"</span>, FileHeader-&gt;SizeOfOptionalHeader);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Characteristics:%04x\n"</span>, FileHeader-&gt;Characteristics);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"----------OptionalHeader----------\n"</span>);</span><br><span class="line">	PIMAGE_OPTIONAL_HEADER32 OptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pNtHeader + <span class="number">4</span> + <span class="keyword">sizeof</span>(_IMAGE_FILE_HEADER));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  Magic:%04x\n"</span>, OptionalHeader-&gt;Magic);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"- SizeOfCode:%08x\n"</span>, OptionalHeader-&gt;SizeOfCode);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"- SizeOfInitializedData:%08x\n"</span>, OptionalHeader-&gt;SizeOfInitializedData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"- SizeOfUninitializedData:%08x\n"</span>, OptionalHeader-&gt;SizeOfUninitializedData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  AddressOfEntryPoint:%08x\n"</span>, OptionalHeader-&gt;AddressOfEntryPoint);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"- BaseOfCode:%08x\n"</span>, OptionalHeader-&gt;BaseOfCode);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"- BaseOfData:%08x\n"</span>, OptionalHeader-&gt;BaseOfData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  ImageBase:%08x\n"</span>, OptionalHeader-&gt;ImageBase);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  SectionAlignment:%08x\n"</span>, OptionalHeader-&gt;SectionAlignment);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  FileAlignment:%08x\n"</span>, OptionalHeader-&gt;FileAlignment);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  SizeOfImage:%08x\n"</span>, OptionalHeader-&gt;SizeOfImage);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  SizeOfHeaders:%08x\n"</span>, OptionalHeader-&gt;SizeOfHeaders);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"CheckSum:%08x\n"</span>, OptionalHeader-&gt;CheckSum);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"SizeOfStackReserve:%08x\n"</span>, OptionalHeader-&gt;SizeOfStackReserve);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"SizeOfStackCommit:%08x\n"</span>, OptionalHeader-&gt;SizeOfStackCommit);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"SizeOfHeapReserve:%08x\n"</span>, OptionalHeader-&gt;SizeOfHeapReserve);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"SizeOfHeapCommit:%08x\n"</span>, OptionalHeader-&gt;SizeOfHeapCommit);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"NumberOfRvaAndSizes:%08x\n"</span>, OptionalHeader-&gt;NumberOfRvaAndSizes);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> FileHeader-&gt;SizeOfOptionalHeader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Section_Header</span><span class="params">(LPSTR pFileBuffer, <span class="keyword">int</span> NT_addr, <span class="keyword">int</span> SizeOfOptionalHeader)</span> </span>&#123;</span><br><span class="line">	PIMAGE_FILE_HEADER FileHeader = (PIMAGE_FILE_HEADER)(pFileBuffer + NT_addr + <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">int</span> NumberOfSections = FileHeader-&gt;NumberOfSections;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"----------SectionHeader----------\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"SectionNum:%x\n"</span>, NumberOfSections);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"---------------------------------\n"</span>);</span><br><span class="line">	PIMAGE_SECTION_HEADER SectionHeader = (PIMAGE_SECTION_HEADER)(pFileBuffer + NT_addr + <span class="number">4</span> + <span class="keyword">sizeof</span>(_IMAGE_FILE_HEADER) + SizeOfOptionalHeader);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NumberOfSections; i++) &#123;</span><br><span class="line">		<span class="comment">//Name最多只有8个字节，需要手动解析来判断结尾</span></span><br><span class="line">		<span class="keyword">char</span> SectionName[<span class="number">9</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="built_in">memcpy</span>(SectionName, SectionHeader-&gt;Name, <span class="number">8</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"* Name:%s\n"</span>, SectionName);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"* Misc:%08x\n"</span>, SectionHeader-&gt;Misc.VirtualSize);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"* VirtualAddress:%08x\n"</span>, SectionHeader-&gt;VirtualAddress);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"* SizeOfRawData:%08x\n"</span>, SectionHeader-&gt;SizeOfRawData);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"* PointerToRawData:%08x\n"</span>, SectionHeader-&gt;PointerToRawData);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"PointerToRelocations:%08x\n"</span>, SectionHeader-&gt;PointerToRelocations);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"PointerToLinenumbers:%08x\n"</span>, SectionHeader-&gt;PointerToLinenumbers);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"NumberOfRelocations:%04x\n"</span>, SectionHeader-&gt;NumberOfRelocations);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"NumberOfLinenumbers:%04x\n"</span>, SectionHeader-&gt;NumberOfLinenumbers);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"* Characteristics:%08x\n"</span>, SectionHeader-&gt;Characteristics);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"---------------------------------\n"</span>);</span><br><span class="line">		SectionHeader = SectionHeader + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	FILE* tFile = fopen(<span class="string">"C:\\Users\\veselwuxin\\Desktop\\wtest.exe"</span>, <span class="string">"rb"</span>);</span><br><span class="line">	<span class="keyword">if</span> (tFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"file open failed\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span> = filesize(tFile);</span><br><span class="line">	<span class="keyword">char</span>* FileBuffer = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="built_in">size</span>);</span><br><span class="line">	<span class="keyword">if</span> (!FileBuffer) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Alloc FileBuffer Failed\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(FileBuffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> freadsize = fread(FileBuffer, <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="built_in">size</span>, tFile);</span><br><span class="line">	<span class="keyword">if</span> (freadsize != <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="built_in">size</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"FileBuffer Write Failed\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"FileBuffer address:%p\n"</span>, FileBuffer);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//_IMAGE_DOS_HEADER</span></span><br><span class="line">	<span class="comment">//_IMAGE_NT_HEADERS</span></span><br><span class="line">	<span class="comment">//_IMAGE_FILE_HEADER</span></span><br><span class="line">	<span class="comment">//_IMAGE_OPTIONAL_HEADER</span></span><br><span class="line">	<span class="comment">//_IMAGE_SECTION_HEADER</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> NT_addr = DOS_Header(FileBuffer);</span><br><span class="line">	<span class="keyword">int</span> SizeOfOptionalHeader = NT_Header(FileBuffer, NT_addr);</span><br><span class="line">	Section_Header(FileBuffer, NT_addr, SizeOfOptionalHeader);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(FileBuffer);</span><br><span class="line">	FileBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	tFile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="程序运行部分截图"><a href="#程序运行部分截图" class="headerlink" title="程序运行部分截图"></a>程序运行部分截图</h1><p><img src="/2020/03/02/PE%E8%8A%82%E8%A1%A8%E8%AF%B4%E6%98%8E/01.png" alt></p>
]]></content>
      <categories>
        <category>PE</category>
      </categories>
  </entry>
  <entry>
    <title>PE头说明</title>
    <url>/2020/02/29/PE%E5%A4%B4%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>对PE头的了解直接决定了对它的利用程度</p>
<a id="more"></a>

<h1 id="PE结构整体图"><a href="#PE结构整体图" class="headerlink" title="PE结构整体图"></a>PE结构整体图</h1><p><img src="/2020/02/29/PE%E5%A4%B4%E8%AF%B4%E6%98%8E/02.jpg" alt></p>
<h1 id="程序读取文件PE头"><a href="#程序读取文件PE头" class="headerlink" title="程序读取文件PE头"></a>程序读取文件PE头</h1><p>PE头分为DOS头和NT头，其中NT头又包括PE标识、PE标准头和PE可选头三个，虽然叫做可选头，但它也是不可缺少的。</p>
<p>这里通过一个程序将其内容都读取出来，并对关键内容进行了标识，其中所列出来的PE头信息都是必须要记住的，加 * 的内容都是重中之重，加 - 的内容是编译器填写并且在现在的程序中是没有用处的，即修改不影响运行的，我们可以对其进行利用。</p>
<p>这里先给出最后的运行结果图</p>
<p><img src="/2020/02/29/PE%E5%A4%B4%E8%AF%B4%E6%98%8E/01.png" alt></p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">filesize</span><span class="params">(FILE* file)</span> </span>&#123;</span><br><span class="line">	fseek(file, <span class="number">0</span>, SEEK_END);</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span> = ftell(file);</span><br><span class="line">	fseek(file, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DOS_Header</span><span class="params">(LPSTR pFileBuffer)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"----------DOSHeader----------\n"</span>);</span><br><span class="line">	PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// *(PWORD)pDosHeader != IMAGE_DOS_SIGNATURE</span></span><br><span class="line">	<span class="keyword">if</span> ((WORD)pDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"DOSHeader failed:MZ"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  e_magic:%x\n"</span>, (WORD)pDosHeader-&gt;e_magic);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  e_lfanew:%08x\n"</span>, (DWORD)pDosHeader-&gt;e_lfanew);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> pDosHeader-&gt;e_lfanew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NT_Header</span><span class="params">(LPSTR pFileBuffer, <span class="keyword">int</span> NT_addr)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"----------NTHeader----------\n"</span>);</span><br><span class="line">	PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pFileBuffer + NT_addr);</span><br><span class="line">	<span class="keyword">if</span> ((WORD)pNtHeader-&gt;Signature != IMAGE_NT_SIGNATURE) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"NTHeader failed:NT"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Signature:%08x\n"</span>, (DWORD)pNtHeader-&gt;Signature);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"----------FileHeader----------\n"</span>);</span><br><span class="line">	PIMAGE_FILE_HEADER FileHeader = (PIMAGE_FILE_HEADER)((DWORD)pNtHeader + <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  Machine:%04x\n"</span>, FileHeader-&gt;Machine);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  NumberOfSections:%04x\n"</span>, FileHeader-&gt;NumberOfSections);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"TimeDateStamp:%08x\n"</span>, FileHeader-&gt;TimeDateStamp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  SizeOfOptionalHeader:%04x\n"</span>, FileHeader-&gt;SizeOfOptionalHeader);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Characteristics:%04x\n"</span>, FileHeader-&gt;Characteristics);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"----------OptionalHeader----------\n"</span>);</span><br><span class="line">	PIMAGE_OPTIONAL_HEADER32 OptionalHeader = (PIMAGE_OPTIONAL_HEADER32)((DWORD)pNtHeader + <span class="number">4</span> + <span class="keyword">sizeof</span>(_IMAGE_FILE_HEADER));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  Magic:%04x\n"</span>, OptionalHeader-&gt;Magic);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"- SizeOfCode:%08x\n"</span>, OptionalHeader-&gt;SizeOfCode);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"- SizeOfInitializedData:%08x\n"</span>, OptionalHeader-&gt;SizeOfInitializedData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"- SizeOfUninitializedData:%08x\n"</span>, OptionalHeader-&gt;SizeOfUninitializedData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  AddressOfEntryPoint:%08x\n"</span>, OptionalHeader-&gt;AddressOfEntryPoint);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"- BaseOfCode:%08x\n"</span>, OptionalHeader-&gt;BaseOfCode);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"- BaseOfData:%08x\n"</span>, OptionalHeader-&gt;BaseOfData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  ImageBase:%08x\n"</span>, OptionalHeader-&gt;ImageBase);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  SectionAlignment:%08x\n"</span>, OptionalHeader-&gt;SectionAlignment);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  FileAlignment:%08x\n"</span>, OptionalHeader-&gt;FileAlignment);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  SizeOfImage:%08x\n"</span>, OptionalHeader-&gt;SizeOfImage);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"*  SizeOfHeaders:%08x\n"</span>, OptionalHeader-&gt;SizeOfHeaders);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"CheckSum:%08x\n"</span>, OptionalHeader-&gt;CheckSum);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"SizeOfStackReserve:%08x\n"</span>, OptionalHeader-&gt;SizeOfStackReserve);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"SizeOfStackCommit:%08x\n"</span>, OptionalHeader-&gt;SizeOfStackCommit);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"SizeOfHeapReserve:%08x\n"</span>, OptionalHeader-&gt;SizeOfHeapReserve);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"SizeOfHeapCommit:%08x\n"</span>, OptionalHeader-&gt;SizeOfHeapCommit);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"NumberOfRvaAndSizes:%08x\n"</span>, OptionalHeader-&gt;NumberOfRvaAndSizes);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	FILE* tFile = fopen(<span class="string">"C:\\Users\\veselwuxin\\Desktop\\wtest.exe"</span>, <span class="string">"rb"</span>);</span><br><span class="line">	<span class="keyword">if</span> (tFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"file open failed\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span> = filesize(tFile);</span><br><span class="line">	<span class="keyword">char</span>* FileBuffer = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="built_in">size</span>);</span><br><span class="line">	<span class="keyword">if</span> (!FileBuffer) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Alloc FileBuffer Failed\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(FileBuffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> freadsize = fread(FileBuffer, <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="built_in">size</span>, tFile);</span><br><span class="line">	<span class="keyword">if</span> (freadsize != <span class="keyword">sizeof</span>(<span class="keyword">char</span>) * <span class="built_in">size</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"FileBuffer Write Failed\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"FileBuffer address:%p\n"</span>, FileBuffer);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//_IMAGE_DOS_HEADER</span></span><br><span class="line">	<span class="comment">//_IMAGE_NT_HEADERS</span></span><br><span class="line">	<span class="comment">//_IMAGE_FILE_HEADER</span></span><br><span class="line">	<span class="comment">//_IMAGE_OPTIONAL_HEADER</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> NT_addr = DOS_Header(FileBuffer);</span><br><span class="line">	NT_Header(FileBuffer, NT_addr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(FileBuffer);</span><br><span class="line">	FileBuffer = <span class="literal">NULL</span>;</span><br><span class="line">	tFile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码地址：<a href="https://github.com/veselwuxin/code.seclibs.com/blob/master/pe/Read_PE_Header.cpp" target="_blank" rel="noopener">GitHub</a></p>
<h1 id="PE头结构体"><a href="#PE头结构体" class="headerlink" title="PE头结构体"></a>PE头结构体</h1><h2 id="IMAGE-DOS-HEADER"><a href="#IMAGE-DOS-HEADER" class="headerlink" title="_IMAGE_DOS_HEADER"></a>_IMAGE_DOS_HEADER</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>      <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD   e_magic;                     <span class="comment">// Magic number</span></span><br><span class="line">    WORD   e_cblp;                      <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD   e_cp;                        <span class="comment">// Pages in file</span></span><br><span class="line">    WORD   e_crlc;                      <span class="comment">// Relocations</span></span><br><span class="line">    WORD   e_cparhdr;                   <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD   e_minalloc;                  <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD   e_maxalloc;                  <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD   e_ss;                        <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD   e_sp;                        <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD   e_csum;                      <span class="comment">// Checksum</span></span><br><span class="line">    WORD   e_ip;                        <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD   e_cs;                        <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD   e_lfarlc;                    <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD   e_ovno;                      <span class="comment">// Overlay number</span></span><br><span class="line">    WORD   e_res[<span class="number">4</span>];                    <span class="comment">// Reserved words</span></span><br><span class="line">    WORD   e_oemid;                     <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD   e_oeminfo;                   <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD   e_res2[<span class="number">10</span>];                  <span class="comment">// Reserved words</span></span><br><span class="line">    LONG   e_lfanew;                    <span class="comment">// File address of new exe header</span></span><br><span class="line">  &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure>

<h2 id="IMAGE-NT-HEADERS"><a href="#IMAGE-NT-HEADERS" class="headerlink" title="_IMAGE_NT_HEADERS"></a>_IMAGE_NT_HEADERS</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>

<h2 id="IMAGE-FILE-HEADER"><a href="#IMAGE-FILE-HEADER" class="headerlink" title="_IMAGE_FILE_HEADER"></a>_IMAGE_FILE_HEADER</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine;</span><br><span class="line">    WORD    NumberOfSections;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    DWORD   PointerToSymbolTable;</span><br><span class="line">    DWORD   NumberOfSymbols;</span><br><span class="line">    WORD    SizeOfOptionalHeader;</span><br><span class="line">    WORD    Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>

<h2 id="IMAGE-OPTIONAL-HEADER"><a href="#IMAGE-OPTIONAL-HEADER" class="headerlink" title="_IMAGE_OPTIONAL_HEADER"></a>_IMAGE_OPTIONAL_HEADER</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    WORD    Magic;</span><br><span class="line">    BYTE    MajorLinkerVersion;</span><br><span class="line">    BYTE    MinorLinkerVersion;</span><br><span class="line">    DWORD   SizeOfCode;</span><br><span class="line">    DWORD   SizeOfInitializedData;</span><br><span class="line">    DWORD   SizeOfUninitializedData;</span><br><span class="line">    DWORD   AddressOfEntryPoint;</span><br><span class="line">    DWORD   BaseOfCode;</span><br><span class="line">    DWORD   BaseOfData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    DWORD   ImageBase;</span><br><span class="line">    DWORD   SectionAlignment;</span><br><span class="line">    DWORD   FileAlignment;</span><br><span class="line">    WORD    MajorOperatingSystemVersion;</span><br><span class="line">    WORD    MinorOperatingSystemVersion;</span><br><span class="line">    WORD    MajorImageVersion;</span><br><span class="line">    WORD    MinorImageVersion;</span><br><span class="line">    WORD    MajorSubsystemVersion;</span><br><span class="line">    WORD    MinorSubsystemVersion;</span><br><span class="line">    DWORD   Win32VersionValue;</span><br><span class="line">    DWORD   SizeOfImage;</span><br><span class="line">    DWORD   SizeOfHeaders;</span><br><span class="line">    DWORD   CheckSum;</span><br><span class="line">    WORD    Subsystem;</span><br><span class="line">    WORD    DllCharacteristics;</span><br><span class="line">    DWORD   SizeOfStackReserve;</span><br><span class="line">    DWORD   SizeOfStackCommit;</span><br><span class="line">    DWORD   SizeOfHeapReserve;</span><br><span class="line">    DWORD   SizeOfHeapCommit;</span><br><span class="line">    DWORD   LoaderFlags;</span><br><span class="line">    DWORD   NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>

<ul>
<li>最后的<code>IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</code>也是比较重要的一块，这里暂时不提。</li>
</ul>
<h1 id="部分PE头说明"><a href="#部分PE头说明" class="headerlink" title="部分PE头说明"></a>部分PE头说明</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WORD e_magic     &quot;MZ标记&quot; 用于判断是否为可执行文件</span><br><span class="line">DWORD e_lfanew     PE头相对于文件的偏移，用于定位PE文件</span><br><span class="line"></span><br><span class="line">WORD Machine     程序运行的CPU型号：0x0 任何处理器&#x2F;0x14C 386及后续处理器</span><br><span class="line">WORD NumberOfSections     文件中存在的节的总数,如果要新增节或者合并节 就要修改这个值</span><br><span class="line">DWORD TimeDateStamp     时间戳：文件的创建时间(和操作系统的创建时间无关)，编译器填写的</span><br><span class="line">WORD SizeOfOptionalHeader     可选PE头的大小，32位PE文件默认E0h 64位PE文件默认为F0h  大小可以自定义</span><br><span class="line">WORD Characteristics     每个位有不同的含义，可执行文件值为10F 即0 1 2 3 8位置1 </span><br><span class="line"></span><br><span class="line">WORD Magic     说明文件类型：10B 32位下的PE文件     20B 64位下的PE文件</span><br><span class="line">DWORD SizeOfCode     所有代码节的和，必须是FileAlignment的整数倍 编译器填的  没用</span><br><span class="line">DWORD SizeOfInitializedData     已初始化数据大小的和,必须是FileAlignment的整数倍 编译器填的，没用</span><br><span class="line">DWORD SizeOfUninitializedData     未初始化数据大小的和,必须是FileAlignment的整数倍 编译器填的，没用</span><br><span class="line">DWORD AddressOfEntryPoint     程序入口</span><br><span class="line">DWORD BaseOfCode     代码开始的基址，编译器填的，没用</span><br><span class="line">DWORD BaseOfData     数据开始的基址，编译器填的，没用</span><br><span class="line">DWORD ImageBase     内存镜像基址</span><br><span class="line">DWORD SectionAlignment     内存对齐</span><br><span class="line">DWORD FileAlignment     文件对齐</span><br><span class="line">DWORD SizeOfImage     内存中整个PE文件的映射的尺寸，可以比实际的值大，但必须是SectionAlignment的整数倍</span><br><span class="line">DWORD SizeOfHeaders     所有头+节表按照文件对齐后的大小，否则加载会出错</span><br><span class="line">DWORD CheckSum     校验和，一些系统文件有要求，用来判断文件是否被修改，一般是驱动级的程序需要，但是算法是已知的，可以修改完成后自己重新计算出CheckSum的值</span><br><span class="line">DWORD SizeOfStackReserve     初始化时保留的堆栈大小</span><br><span class="line">DWORD SizeOfStackCommit     初始化时实际提交的大小</span><br><span class="line">DWORD SizeOfHeapReserve     初始化时保留的堆大小</span><br><span class="line">DWORD SizeOfHeapCommit     初始化时实践提交的大小</span><br><span class="line">DWORD NumberOfRvaAndSizes     目录项数目</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>PE</category>
      </categories>
  </entry>
  <entry>
    <title>进制的本质</title>
    <url>/2020/02/25/%E8%BF%9B%E5%88%B6%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    <content><![CDATA[<p>什么是进制，进制的本质又是什么，为什么在计算的时候都会把十进制作为中间转换，其实这样的思维完全是错误的，进制的本质并不是我们熟悉的十进制。</p>
<a id="more"></a>

<h1 id="进制的本质"><a href="#进制的本质" class="headerlink" title="进制的本质"></a>进制的本质</h1><p>进制的本质就是查表，与各种的转换没有任何关系，并不是说计算八进制，就把它转为十进制计算后再转回八进制，这种思想本来就是错误的，<strong>进制的本质就是写表和查表</strong>，我们之所以对十进制的特别熟悉，就是因为我们把十进制相关的表记住了，并不是因为十进制就是进制的基础。</p>
<h1 id="正常的三进制的表示"><a href="#正常的三进制的表示" class="headerlink" title="正常的三进制的表示"></a>正常的三进制的表示</h1><p>这里用三进制的形式来表示是为了方便说明问题，在正常的三进制中有三个元素0、1、2，它们所表示出来的数是这个样子的。</p>
<p><img src="/2020/02/25/%E8%BF%9B%E5%88%B6%E7%9A%84%E6%9C%AC%E8%B4%A8/1.png" alt></p>
<p>其中的每一个数是怎么写出来的，其实都是根据最前面的0、1、2三个数查出来的，后面的所有数都是由前面的数查出来的。</p>
<p>首先先写出0、1、2，再往后的话就需要进位，一位已经满足不了我们现在的需求了，所以需要两位来进行表示，如何从一位表示跨度到两位表示，这里提供一个方法：在一位的0、1、2前面补一个0，在两位看来，一位的表示其实就是第一位为0，这样写出来的时候，会比较方便观察和理解。</p>
<p><img src="/2020/02/25/%E8%BF%9B%E5%88%B6%E7%9A%84%E6%9C%AC%E8%B4%A8/2.png" alt></p>
<p>看图，当前数字为02，需要往后走一位，按照前面0、1、2的顺序来看，接下来，2应该往后走一位，但是后面没有数字了，就需要返回开始的数字重新来一遍，此时应该把这一轮结束的标志记录到前面，也就是我们所说的进位，所以0应该变为1，2应该变为0，所以接下来的数字应该为10。</p>
<p><img src="/2020/02/25/%E8%BF%9B%E5%88%B6%E7%9A%84%E6%9C%AC%E8%B4%A8/3.png" alt></p>
<p>接下来，继续往后加一，也就是再往后挪一个，0往后走一步就变成了1，所以接下来是11，再往后是12。</p>
<p><img src="/2020/02/25/%E8%BF%9B%E5%88%B6%E7%9A%84%E6%9C%AC%E8%B4%A8/4.png" alt></p>
<p>接下来又到了所谓进位的时候，2往后走一步，发现又需要重新回到开头，开始新的一轮，所以2变成了0，而前面记录的又需要再加一个，1往后走一步，就变成了2，所以接下来的数就变成了20。</p>
<p><img src="/2020/02/25/%E8%BF%9B%E5%88%B6%E7%9A%84%E6%9C%AC%E8%B4%A8/5.png" alt></p>
<p>再往后就依次类推，最后就得到了文章开头所得到的三进制的表格。</p>
<h1 id="正常的三进制的运算"><a href="#正常的三进制的运算" class="headerlink" title="正常的三进制的运算"></a>正常的三进制的运算</h1><p>在有了前面的这个基础之后，我们开始制作三进制的加法法则和乘法法则。</p>
<h2 id="加法法则"><a href="#加法法则" class="headerlink" title="加法法则"></a>加法法则</h2><p>因为三进制所涉及到的数字比较少，所以对于加法法则来说也是比较少的。</p>
<p><img src="/2020/02/25/%E8%BF%9B%E5%88%B6%E7%9A%84%E6%9C%AC%E8%B4%A8/6.png" alt></p>
<p><code>1+1=</code> 也就是在1的基础上，往后数一个数，参照第一张表，1往后数一数是2，所以<code>1+1=2</code>；然后看<code>1+2=</code> 依照前面的思路，从1往后数两个数，便是10，所以<code>1+2=10</code>；同理<code>2+2=</code> 也就是在2的基础上往后数两位，便是11，所以<code>2+2=11</code>。</p>
<p><img src="/2020/02/25/%E8%BF%9B%E5%88%B6%E7%9A%84%E6%9C%AC%E8%B4%A8/7.png" alt></p>
<p>加法法则就是往后数个数，那同理乘法法则就是往后数成倍的个数。</p>
<h2 id="乘法法则"><a href="#乘法法则" class="headerlink" title="乘法法则"></a>乘法法则</h2><p>由于三进制的基数太小，其中的乘法应用体现不出来，与加法法则的效果是一样的</p>
<p><img src="/2020/02/25/%E8%BF%9B%E5%88%B6%E7%9A%84%E6%9C%AC%E8%B4%A8/8.png" alt></p>
<h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><p>由于三进制的范围太小，在七进制运算的时候详细说</p>
<h1 id="正常的七进制的运算"><a href="#正常的七进制的运算" class="headerlink" title="正常的七进制的运算"></a>正常的七进制的运算</h1><p>开始选择三进制是为了后面对进制进行变化的时候方便，结果体现不出来加法法则和乘法法则的实际使用效果了，这里就使用七进制来展示一下具体的使用方法，它们的操作是一样的。</p>
<p>首先，先写出一堆七进制的数，仔细观察还是能发现一些规律的，但是一定要按照数个数的思维去找规律。</p>
<p><img src="/2020/02/25/%E8%BF%9B%E5%88%B6%E7%9A%84%E6%9C%AC%E8%B4%A8/9.png" alt></p>
<p>接下来是加法法则和乘法法则</p>
<h2 id="加法法则-1"><a href="#加法法则-1" class="headerlink" title="加法法则"></a>加法法则</h2><p>依照前面数数的方式来从表里面找就可以了，这里用<code>4+5=</code> 来举例，按照前面的方法，就是从4开始往后数5个数，便为12，其他的都是同样的方法。</p>
<p><img src="/2020/02/25/%E8%BF%9B%E5%88%B6%E7%9A%84%E6%9C%AC%E8%B4%A8/10.png" alt></p>
<h2 id="乘法法则-1"><a href="#乘法法则-1" class="headerlink" title="乘法法则"></a>乘法法则</h2><p>乘法就是多次的加法，这里用<code>2*3=</code> 来举例，2*3转换成加法就是两个3相加，也就是从3往后数3个数，便为6，所以<code>2*3=6</code>，其他的方法类似。</p>
<p><img src="/2020/02/25/%E8%BF%9B%E5%88%B6%E7%9A%84%E6%9C%AC%E8%B4%A8/11.png" alt></p>
<h2 id="基本运算-1"><a href="#基本运算-1" class="headerlink" title="基本运算"></a>基本运算</h2><p>进制的加减乘除运算依靠前面写出来的两个加发表和乘法表就可以满足了，一切依旧是查表，记住进制的本质就是查表。</p>
<p>加：<code>23456+54356=</code></p>
<p>我们从最后一个位看，(这里一直都是说的第几位，因为个位十位等都是十进制才有的，其他进制并没有这么个叫法)，是两个6相加，查表得15，所以<strong>最后一位结果为5</strong>，1向前进位；再看倒数第二位，两个5相加，查表的13，加上刚刚进位的1，通过查表可知结果为14，所以<strong>倒数第二位结果为4</strong>，1向前进位；4和3相加，查表得10，进位得11，<strong>结果为1</strong>，1向前进位；3和4相加，查表得10，进位得11，<strong>结果为1</strong>，1向前进位；2和5相加，查表得10，进位<strong>得11</strong>；所以最终结果为<strong>111145</strong>。</p>
<p>减：<code>5621-654=</code></p>
<p>看最后一位，1减4减不过，借位得11，11减4，查表可知<code>4+4=11</code>，所以<strong>最后一位结果为4</strong>；2被借位为1，1减5减不过，借位得11，11减5查表<strong>得3</strong>；6被借位为5，5减6减不过，借位得15，15减6查表<strong>得6</strong>；5被借位<strong>为4</strong>，所以最终结果为<strong>4634</strong>。</p>
<p>乘：<code>234*65=</code></p>
<p>看最后一位，4乘5，查表得26，<strong>结果为6</strong>，2进位；3乘5，查表得21，进位得23，<strong>结果为3</strong>，2进位；2乘5，查表得13，进位<strong>得15</strong>，所以第一个数得结果<strong>为1536</strong>；然后算到处第二位，同样的方法<strong>得2103</strong>；最后1536加21030，(乘法计算的最后两数相加是错位的，所以这里写成了21030)<strong>得22566</strong>。</p>
<p>除法也是同样的方法。</p>
<h1 id="变异的三进制运算"><a href="#变异的三进制运算" class="headerlink" title="变异的三进制运算"></a>变异的三进制运算</h1><p>前面已经把正常情况下的进制转换和运算说清楚了，但为什么前面一直说它们是正常的，因为那些符合我们平常的运算概念，但是谁又规定三进制必须是0、1、2，我要是选!、@、#作为三进制的基本元素可以不？可以，那我使用2、0、1作为基本元素可以不？一点问题也没有，那我能不能使用三个图片来作为基本元素？也是没有问题的；而且在这样的情况下，还有一个好处，不知道你的进制规范的是看不懂其中具体的内容的，这也就是通过自定义进制元素的方式实现了所谓的<strong>进制加密</strong>。</p>
<p>那我们就按照2、0、1作为基本元素来写一下这个情况下的三进制表示。</p>
<p><img src="/2020/02/25/%E8%BF%9B%E5%88%B6%E7%9A%84%E6%9C%AC%E8%B4%A8/12.png" alt></p>
<p>最后我们换一种方式来表示，再来感受一下进制</p>
<p><img src="/2020/02/25/%E8%BF%9B%E5%88%B6%E7%9A%84%E6%9C%AC%E8%B4%A8/13.png" alt></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>进制的本质就是查表，进制的本质就是掰手指头数数。</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>函数调用堆栈图-c语言</title>
    <url>/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>我们就使用一个简单的c语言程序来对描述一下在函数调用的时候都发生了什么。</p>
<a id="more"></a>

<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-1.png" alt></p>
<p>中间的一小段没有意义的汇编语言是为了方便设置断点，为后面的调试做好铺垫，因为有时会碰到找不到断点位置的情况，使用这个方法，可以在找不到断点的时候向后执行一次，而不破坏我们想调试的程序当前的堆栈状态，这里对main函数和sum函数的效果是类似的，这里直接跟着断点来执行分析sum函数的堆栈操作。</p>
<p>我们先假设初始状态下的堆栈图如下，esp与ebp的真实距离我们省略。</p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-12.png" alt></p>
<p>接下来我们来看一下后面的操作。</p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-13.png" alt></p>
<p>在程序的执行当中，我们一般都是按照从右向左的方式去处理的，这里也不例外，我们可以发现当我们调用sum函数对数字1和数字2进行处理的时候，将数字2和1依次压入栈中，这个时候堆栈的情况是这个样子的，esp的值已经减8。</p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-14.png" alt></p>
<p>接下来调用了call，这时进行了两步操作，先将call后面的地址push进堆栈，然后再jmp到call所调用的地址。</p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-15.png" alt></p>
<p>因为jmp是不会影响堆栈的，所以现在的堆栈情况是这样的</p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-16.png" alt></p>
<p>然后因为编译器的原因在call的时候还会有一个jmp来中转到后面的处理函数，因为jmp不影响堆栈，我们可以忽略掉它，这里是跳转到了sum函数的处理位置。</p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-17.png" alt></p>
<p>此时的堆栈是没有发生变化的，现在开始到了函数调用的关键阶段了。</p>
<p>首先先将ebp的值push到堆栈中，因为用到了ebp寻址的方式，所以这里用这种方式来保存ebp中原本的值，然后将esp的值赋给ebp，用ebp寻址来代替esp寻址，因为esp的值一直在不断的发生变化，使用esp寻址会带来很大的计算负担，此时esp与ebp都指向了同一块地址，其中的内容是原来的ebp的值。</p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-18.png" alt></p>
<p>然后让esp减去了0c0h位，开始提升堆栈了，为程序的运行开辟一个存储空间，这个区域也就是平时所说的缓冲区，因为一个单元是四个字节，c0也就是往上提了48个格，由于位置有限中间依旧省略，此时堆栈就变成了如下的样子。</p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-19.png" alt></p>
<p>后面又进行了一系列的push操作，也是为了方便在后续使用这些寄存器的时候保证它们初始的值不丢失，与前面保存ebp的值是一样的方式。</p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-21.png" alt></p>
<p>然后接下来的四步操作只有一个目的，那就是将中间的48格全部值为CC，CC在调试的时候相当于断点，也就是如果你程序跑过的话，就会触发断点不会再继续执行了。</p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-22.png" alt></p>
<p>lea是交换地址中的值，给eax和ecx赋值是为rep的执行做准备的，stos是将eax中的值赋给edi，rep是执行后面的指令ecx次。</p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-23.png" alt></p>
<p>接下来的两步指令我们忽略，它们是vs编译器添加的调试指令</p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-24.png" alt></p>
<p>因为eax一般是来用作返回值的，所以这里的计算都是跟eax进行计算的，因为我们这里直接使用的是return返回，没有涉及到临时变量，所以不会用到缓冲区来存储。</p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-25.png" alt></p>
<p>接下来的三步pop，是将之前存储在栈中的元素都恢复到它原来的位置。</p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-26.png" alt></p>
<p>此时的堆栈情况就变成了，上面的值还是没有清除的，它们现在已经是垃圾数据的，下一次填充的时候会把它们覆盖掉，这也就造成了可以在其中获取到某些程序不想让人知道的临时变量值。</p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-27.png" alt></p>
<p>接下来让esp增加0c0，也就恢复到了提升堆栈之前的位置，此时esp与ebp到了一个位置。</p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-28.png" alt></p>
<p>接下来的三步操作依旧可以忽略，它们是vs编译器生成的，用来检测堆栈是否平衡，如果不平衡的话在这里就会产生报错。</p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-29.png" alt></p>
<p>最后就是使用pop，将ebp恢复到之前的位置。</p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-30.png" alt></p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-31.png" alt></p>
<p>最后使用ret回到堆栈中存储的地址，也就是call调用的下一个地址。</p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-32.png" alt></p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-33.png" alt></p>
<p>但是此时还有个问题，esp并没有回到调用前的位置，所以堆栈还是没有平衡的，如果堆栈不平衡，那在不断的执行的过程中，就会发生堆栈溢出，这里编译器是使用外平栈的方式来使堆栈恢复平衡的，它在esp的基础上增加了8。</p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-34.png" alt></p>
<p>此时堆栈也就恢复到了平衡状态</p>
<p><img src="/2020/02/14/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE-c%E8%AF%AD%E8%A8%80/image-35.png" alt></p>
<p>还有另一种方式是使用内平栈的方式，即在函数内部就将堆栈恢复平衡，使用ret 8的方式。</p>
<p>再往后面的操作就是main函数的堆栈平衡的处理了，与上面的函数调用类似，就不提了。</p>
]]></content>
      <categories>
        <category>C/C++</category>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>基于数组越界的缓冲区溢出</title>
    <url>/2020/02/14/%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<p>上一篇文章说了函数调用时候的堆栈变化，这里就基于这个内容来验证一下基于数组越界的缓冲区溢出。</p>
<a id="more"></a>

<p>在c语言中，数组必须是静态的，也就是在定义的时候必须明确数组的大小，在根本上来说，这个是堆栈提升的原因，只有在数组的大小确定的时候，才能明确堆栈到底要提升多少，如果数组的大小是动态变化的，就极容易发生缓冲区溢出；而且c语言也不具备Java等语言中静态分析的功能，不会去检测数组是否有上溢或者下溢，其边界的检验是有程序员负责的，所以这就造成了一些问题，我们可以通过数组越界来改变一些内容。</p>
<p>首先来看一下这次的实验程序</p>
<p><img src="/2020/02/14/%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-36.png" alt></p>
<p>正常来说，test1函数并没有被调用，所以是不会打印出12345的，而实际的情况却不是这样的</p>
<p><img src="/2020/02/14/%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-37.png" alt></p>
<p>造成这样的情况，就是由于数组越界而造成的缓冲区溢出，这其中还有一个编译器的坑，在后面再解释。</p>
<p>我们直接在数组处下断点，前面的提升堆栈等操作就不细说了，前一篇文章已经走过一边流程了，这里直接给出到这一步的堆栈图。</p>
<p><img src="/2020/02/14/%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-41.png" alt></p>
<p>然后我们看一下编译器是如何处理数组赋值的内容的</p>
<p><img src="/2020/02/14/%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-40.png" alt></p>
<p>经过这段赋值操作，此时堆栈已经变成了下图，这里单独从中拎出来10行方便观看。</p>
<p><img src="/2020/02/14/%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-42.png" alt></p>
<p>通过堆栈图我们可以很清晰的看到，明明只有8个数，它确是从ebp-24h开始排的，也就是说ebp-4的位置是没有使用的，这个也就是前面所说的坑，经过查询资料，发现从vs2010开始，ebp-4就都没有使用，具体是用来做什么的，暂时还不清楚，所以如果这里你使用的是vc6.0的话，这里就是从ebp-4开始排的。</p>
<p>好了说了上面那个坑，接着回来说堆栈图，在上一篇文章里我们已经很清楚函数在调用的时候会先把call语句的下一行地址压入栈中，所以图中b[10]的位置也就代表了ret返回地址的位置，在vc6.0中此处应该是b[9]，如果我们将这个地址替换为我们想让程序到达的位置，也就可以控制程序的运行轨迹了。</p>
<p><img src="/2020/02/14/%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-43.png" alt></p>
<p>在后面的操作就是将test1函数的地址赋给了b[10]，也就代替了之前函数的返回地址，这个函数在执行完成后便会返回test1函数的位置081137Ah。</p>
<p><img src="/2020/02/14/%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/image-44.png" alt></p>
<p>也就达到了缓冲区溢出的效果。</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
  </entry>
  <entry>
    <title>算法之二分查找（上）-c语言实现</title>
    <url>/2020/02/07/%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E4%B8%8A%EF%BC%89-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>使用递归来实现的，逻辑比较简单，也不是太复杂的东西，直接上代码了</p>
<a id="more"></a>

<p>如果需要下载代码，请移步至文末</p>
<p><img src="/2020/02/07/%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E4%B8%8A%EF%BC%89-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/carbon-7.png" alt></p>
<p>代码：<a href="https://github.com/veselwuxin/code.seclibs.com/blob/master/c/Simple_binary_search.c" target="_blank" rel="noopener">GitHub</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>算法之二分查找（上）</title>
    <url>/2020/02/07/%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<p>二分查找在平时的生活中也挺常用的，比如说以前玩的猜数游戏，每次都取中间数，然后得知是大了，还是小了，这个例子也就是二分查找。</p>
<a id="more"></a>

<p>比如下面的这个例子，要查找有没有数值19，其中low和high是查找的区间的下标，mid是查找区域的中间值的下标。</p>
<p><img src="/2020/02/07/%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E4%B8%8A%EF%BC%89/8bce81259abf0e9a06f115e22586b829.jpg" alt></p>
<p>二分查找的思想是比较容易理解的，而且它的时间复杂度也是比较低的。假设数据大小为n，每次查找完后都会缩小一半，即为除以2，最坏的情况也就是一直到查找空间为空的时候，所以它们的变化为n，n/2，n/4，n/8，…，n/2k，当n/2k=1时，k即为缩小的次数，因为每次都只涉及到两个数的大小比较，所以k次操作的时间复杂度为O(k)，又因为n/2k=1，所以k=log2n，时间复杂度也就是O(logn)，这是一个非常恐怖的数量级了，比如n为2的32次方，大约是四十多亿，用二分查找来查找里面的一个数的话，最多比较32次也就可以得到这个值了，这是一个非常恐怖的情况。</p>
<p>上面的原理已经很明确了，所以二分查找的实现并不是很复杂，但是有一个前提条件，有序数组中不存在重复元素，只有在这个情况下，二分查找的实现才是相对简单的，具体的实现在下一篇文章里提及。</p>
<hr>
<p>虽然二分查找时间复杂度低，查找起来非常高效，但它也有一定的适用条件的。</p>
<p>首先，二分查找是依赖于数组的，如果使用其他的数据结构来实现的话，二分查找的时间复杂度将会变的非常高，因为数组在下标随机访问的时候，时间复杂度是O(1)，而链表随机访问的时间复杂度是O(n)。</p>
<p>而且它必须是有序的，前面也说过排序算法，时间复杂度最低的为O(nlogn)，如果使用的场景是没有大量的插入和删除操作，一次排序可以多次查找的情况，那排序所的成本就可以被均摊，否则二分查找将不再适用，动态数据集合的查找，我们需要使用其他的算法才可以。</p>
<p>最后就是要注意要查找的数据量不能太大或者太小，太小的话，遍历就足以满足；太大的话，因为它是基于数组这种数据结构的，它所需要的连续的内存空间就是一个非常大的障碍。</p>
<hr>
<p>参考文档</p>
<p>极客时间-数据结构与算法之美</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx学习-架构</title>
    <url>/2020/02/06/Nginx%E5%AD%A6%E4%B9%A0-%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p>Nginx程序架构图如下</p>
<a id="more"></a>

<p><img src="/2020/02/06/Nginx%E5%AD%A6%E4%B9%A0-%E6%9E%B6%E6%9E%84/16547068-40244f461dad5a22.png" alt></p>
<p>后面就先按照这个图所展示出来的内容对Nginx的架构进行一次梳理，文中所涉及到的内容，主要都是针对Linux系统的。</p>
<p>最上面的Master进程是管理员直接控制的，也只有Master进行接受管理员信号，一个Master用户可以fork多个Worker进程，一个Worker进程可以响应多个用户请求。</p>
<ul>
<li>Master进程负责加载配置文件，启动worker进程和平滑升级。</li>
<li>Worker进程处理并响应用户的请求。</li>
</ul>
<p>每个Worker都是由核心模块core和多个模块modules组成的，比如有http协议的ht_core模块，为了功能完善还有很多其它模块，如实现负载均衡的ht_upstream模块，ht_proxy反代模块，ht_fastcgi模块，memcache模块等。</p>
<p>因为Nginx是高度模块化的，我们在用到哪个模块的时候，便将哪个模块编译或者载入就可以了，比如基于ht_core可以与web通信， 基于ht_fastcgi模块可与php通信，基于memcache模块可与mamcache通信。</p>
<p>这里来解释一下什么是FastCGI，CGI全称”通用网关接口”（Common Gateway Interface），用于HTTP服务器与其它机器上的程序服务通信交流的一种工具，CGI程序须运行在网络服务器上；但是由于CGI的性能和安全性都比较差，处理高并发几乎是不可用的，所以就诞生了FastCGI，FastCGI是一个可伸缩地、高速地在HTTP服务器和动态脚本语言间通信的接口（FastCGI接口在Linux下是socket（可以是文件socket，也可以是ip socket）），主要优点是把动态语言和HTTP服务器分离开来。多数流行的HTTP服务器都支持FastCGI，包括Apache、Nginx和lightpd，同时它也被许多脚本语言所支持，包括PHP等。</p>
<p>Nginx不支持对外部动态程序的直接调用或者解析，所有的外部程序（包括PHP）必须通过FastCGI接口来调用。FastCGI接口在Linux下是socket（可以是文件socket，也可以是ip socket）。为了调用CGI程序，还需要一个FastCGI的wrapper，这个wrapper绑定在某个固定socket上，如端口或者文件socket。当Nginx将CGI请求发送给这个socket的时候，通过FastCGI接口，wrapper接收到请求，然后派生出一个新的线程，这个线程调用解释器或者外部程序处理脚本并读取返回数据；接着，wrapper再将返回的数据通过FastCGI接口，沿着固定的socket传递给Nginx；最后，Nginx将返回的数据发送给客户端，这就是Nginx+FastCGI的整个运作过程。</p>
<p>FastCGI的主要优点是把动态语言和HTTP服务器分离开来，是Nginx专一处理静态请求和向后转发动态请求，而PHP/PHP-FPM服务器专一解析PHP动态请求。</p>
<p>说完Nginx+FastCGI后，继续说前面的模块，memcache是一个分布式的高速缓存系统，常用来做缓存服务器、将从数据库查询的数据缓存起来,减少数据库查询、加快查询速度。</p>
<p>然后说图中用户与Nginx交互的部分，在与用户请求进行交互的时候，通过kevent、epoll和select来实现多路复用，实现处理并发用户请求，这里是因为Nginx采用的是多进程（单线程）的模式，采用多进程可以提高并发效率，并且各进程之间相互独立，一个Worker进程挂掉之后不会影响其他进程的运行。</p>
<p>到这里为止上面图中上半部分就说完了，主要就是nginx与用户和后端程序之间的关系，此外Nginx还提供了缓存机制，支持高级I/O机制、sendfile机制、AIO机制(异步非阻塞I/O)、mmap机制等。</p>
<p>我们先来说sendfile机制，在网上查到的所有资料里都提到sendfile机制可以提高文件传输的性能。在传统的文件传输中，使用的是read/write方式来进行文件与socket的传输，所需要经过的流程是这样的</p>
<ul>
<li>调用read函数，文件数据被copy到内核缓冲区</li>
<li>read函数返回，文件数据从内核缓冲区copy到用户缓冲区</li>
<li>write函数调用，将文件数据从用户缓冲区copy到内核与socket相关的缓冲区。</li>
<li>数据从socket缓冲区copy到相关协议引擎。</li>
</ul>
<p>总结一下就是 <strong>硬盘—&gt;内核buf—&gt;用户buf—&gt;socket相关缓冲区—&gt;协议引擎</strong> ，用一张图来表示，就是这个样子的</p>
<p><img src="/2020/02/06/Nginx%E5%AD%A6%E4%B9%A0-%E6%9E%B6%E6%9E%84/20150409011328015-1.jpg" alt></p>
<p>而在引入sendfile机制以后，数据的流程变为了这样</p>
<ul>
<li>sendfile系统调用，文件数据被copy至内核缓冲区</li>
<li>再从内核缓冲区copy至内核中socket相关的缓冲区</li>
<li>最后再socket相关的缓冲区copy到协议引擎</li>
</ul>
<p>可以发现，引入sendfile机制以后，省去了拷贝到用户buf的过程，流程就变成了下图的样子</p>
<p><img src="/2020/02/06/Nginx%E5%AD%A6%E4%B9%A0-%E6%9E%B6%E6%9E%84/20150409011333806.jpg" alt></p>
<p>nginx在支持了sendfile系统调用后，避免了内核层与用户层的上线文切换（content swith）工作，大大减少了系统性能的开销。</p>
<p>前面说了这么多，都没有绕开内核缓冲区和用户缓冲区，那它们分别又是什么东西？</p>
<p>这里首先先区分一下缓冲区buffer和缓存cache是两个完全不同的东西，buffer是减少调用次数，集中调用，提高系统性能的，而cache是将读取过的数据保留下来，如果重新读取的时候发现已经读取过，就不需要再去读硬盘数据了。</p>
<p><img src="/2020/02/06/Nginx%E5%AD%A6%E4%B9%A0-%E6%9E%B6%E6%9E%84/Untitled.png" alt></p>
<p>上图是一个计算机系统运行时的简化模型，在说用户进程和系统进程之前还需要再说一下内核态(kernel mode)和用户态(user mode)，内核态可以访问系统资源，比如CPU、IO设备、进程管理、内存、进程间通信IPC、网络通信等，这些资源在用户进程中是不能直接访问的，需要经过操作系统才可以，这些有操作系统提供的功能也叫做系统调用。</p>
<p>下图是用户通过shell来对文件进行操作的示例图，它们都是经过内核来进行操作的，而提供这些限制的基础就是CPU提供的内核态和用户态。</p>
<p><img src="/2020/02/06/Nginx%E5%AD%A6%E4%B9%A0-%E6%9E%B6%E6%9E%84/Untitled-1.png" alt></p>
<p>前面说了用户进程在访问系统资源的时候，需要先切换到内核态，在这之前有很多的堆栈、内存环境等需要提前准备好，在调用结束以后，必须恢复到用户态，这其中的堆栈等又必须回到用户进程的上下文，这其中的切换就会消耗大量的资源。所以用户缓冲区就是在读取文件的时候申请的一块内存空间，也就是buffer，然后程序都是从buffer中获取数据的，只有在内存空间使用完后才会进行下一次调用来填充buffer，这样就减少了系统调用的次数，减少了在用户态和内核态之间切换的消耗时间。</p>
<p>当然内核也有它自己的缓冲区，在用户进程要从磁盘读取数据的时候，内核一般不会去读磁盘，而是将内核缓冲区中的数据复制给用户进程缓冲区，如果内核缓冲区没有数据的话，内核会将请求加入到请求队列中，然后将进程挂起，去处理其他的进程，直到内核缓冲区读取到数据以后，才会将内核缓冲区中的数据复制给用户进程缓冲区，然后通知进程，当然不同的io模型，在调度方式上也是有一些差异的；所以内核缓冲区就在OS级别，提高了磁盘的IO效率。</p>
<p>到这里sendfile机制也就说完了，接着用刚刚讲的内核和用户进程的知识来说一下AIO机制(异步非阻塞I/O)，我们先来看阻塞，先上图，看一下阻塞和非阻塞的区别</p>
<p><img src="/2020/02/06/Nginx%E5%AD%A6%E4%B9%A0-%E6%9E%B6%E6%9E%84/Untitled-2.png" alt></p>
<p><img src="/2020/02/06/Nginx%E5%AD%A6%E4%B9%A0-%E6%9E%B6%E6%9E%84/Untitled-3.png" alt></p>
<p>在两个图的对比当中，可以看到，在阻塞IO中，如果数据没有准备好你就只能等着，直到数据准备好以后才可以再继续执行，这对于Nginx的Worker来说明显是很不适用的，而非阻塞的IO，当数据没有准备好时，我可以返回先去做其他的事情，过一会再来问一下，如果没有准备好，我再去处理其他的事情，直到你准备好，我过来开始拷贝数据，在这期间明显可以处理很多的事情，对于大量访问的时候也是非常好的，但是这样还有一个问题，虽然非阻塞，但是每隔一段时间就需要请求一下，也是非常浪费资源的，所以也就有了异步，也就是提供一种机制(select/poll/epoll/kquene这样的系统调用)，让你可以同时监控多个事件，调用他们是阻塞的，但是可以设置超时时间，在超时时间之内，如果有事件准备好了就返回。</p>
<p>这样对于大量的并发就非常的友好了，这里的并发请求，是指未处理完的请求，线程只有一个，同时处理的请求只有一个，只是在请求间不断切换，切换是因为异步事件未准备好，主动让出的。这里的切换没有什么代价，可以理解为在循环处理多个准备好的事件；与多线程相比，不需创建线程，每个请求占用的内存也很少，没有上下文切换，事件处理非常轻量级，没有上下文切换的开销，更多并发，只会占更多的内存，这也是现在的网络服务器基本都使用的方式。</p>
<p>最后还有一个mmap机制，mmap机制也就是内存映射，传统的web服务器进行页面输入的时候，都是将硬盘的页面先输入到内核缓冲区，再有内核缓冲区复制一份到web服务器上，mmap机制就是让内核缓冲区与磁盘进行映射，web服务器直接复制页面内容即可，省去了从硬盘复制到内核缓冲区这一过程。</p>
<hr>
<p>上面就是把Nginx所涉及到的功能都说了一遍，从整体角度来看Nginx的功能是这样的。</p>
<p>我们启动Nginx的时候首先会启动一个Master进程，Master进程会根据配置文件的要求fork相应个数的Worker进程（推荐设置worker数与cpu的核数一致，因为更多的worker，会导致进程竞争cpu资源，从而带来不必要的上下文切换，设置为auto即为与cpu一致），当Worker进程接收客户端请求时，如果使用缓存功能，会从缓存中加载数据直接返回给客户端，如果客户端请求的内容内存中没有，就会将请求代理到后端服务器取资源，如果后端服务器是HTTP就使用http模块，如果是php就是用FastCGI模块，然后取出数据后又会将数据在本地缓存下来以提高性能，缓存时基于key-value结构，检索性能时O(1)恒定不变，把key缓存在内存中，检索起来也是非常迅速的。</p>
<hr>
<p>在Worker接受请求这里还有一些操作，这里来补充一下。</p>
<p>在Nginx启动后，Master进程fork出的多个Worker进程，Master能监控Worker进程的运行状态，如果有Worker异常退出后，会自动启动新的Worker进程，在Nginx0.8之前，我们是直接给Master进程发信号的，在重启或者重新加载配置的时候，Master进程在接收到信号之后，会先重新加载配置文件，然后再启动新的Worker进程，并向所有老的Worker进程发送不再接受新请求的信号，并且在处理完所有未处理完的请求后退出，新的Worker在启动后，就开始接受新的请求了；在Nginx0.8之后，我们不会直接对Master发送信号了，比如在执行<strong>./nginx -s reload</strong>的时候，会启动一个新的Nginx进程，该进程解析到reload参数后，知道要重新加载配置文件，它就会向Master进程发送信号，之后的处理与之前直接给Master进程发信号一样了。</p>
<p>还有一点就是所谓的“惊群现象”，在启动后，Master进程首先通过socket()来创建一个sock文件描述符来监听，然后fork出的Worker进程会继承父进程Master的socket文件描述符sockfd，之后Worker进程accept()后将创建已连接描述符(connected descriptor)，然后通过已连接描述符来与客户端通信，由于每一个Worker进程都拥有Master的sockfd，那当链接进来的时候，所有的Worker都会收到通知，并且争着去建立链接，这就是“惊群现象”，这时大量的进程被激活又挂起，只有一个进程可以accept()到这个连接，就消耗了大量的系统资源。在Nginx中提供了一个accept_mutex的东西，这是在accept上加了一把共享锁，即每个Worker进程在执行accept之前都需要先获取锁，获取不到就放弃执行accept()，只有有了这把锁才会去accept()，同一时刻就只有一个Worker进程去接收请求了，这样就不会出现惊群问题了。</p>
<p>但是我在查资料的时候发现了另外一个情况</p>
<blockquote>
<p>在对启动了20个worker的nginx进行压力测试的时候发现：如果把配置文件中event配置块中的accept_mutex开关打开（1.11.3版本之前默认开），就会出现worker压力不均，少量的worker的cpu利用率达到了98%，大部分的worker的压力只有1%左右；如果把accept_mutex关掉，所有的worker的压力差别就不大，而且QPS会有大幅提升；</p>
<p>引用自博客园-sxhlinux</p>
</blockquote>
<p>根据他的测试，在请求属于大量短链接的时候，打开accept_mutex选项是一个比较好的选择，避免了Worker争夺资源而造成的上下文切换以及try_lock的锁的开销，但是对于传输大量数据的TCP长链接来说，打开accept_mutex将会导致压力集中在某个Worker进程上，特别是将worker_connection值设置过大的时候，影响更加明显，具体的设置，需要根据实际情况来进行判定。而且目前新版的Linux内核中增加了EPOLLEXCLUSIVE选项，nginx从1.11.3版本之后也增加了对NGX_EXCLUSIVE_EVENT选项的支持，这样就可以避免多worker的epoll出现的惊群效应，从此之后accept_mutex从默认的on变成了默认off。</p>
<p>很明显所有的文件配置都与具体的实际情况有关，要更好的配置好相关内容必须对所有的内容都要有一个详细的了解才可以。</p>
<hr>
<p>参考文档</p>
<p><a href="https://www.jianshu.com/p/3d9e45082d27" target="_blank" rel="noopener">Nginx架构详解</a></p>
<p><a href="https://www.cnblogs.com/airen123/p/9647345.html" target="_blank" rel="noopener">nginx架构与基础概念</a></p>
<p><a href="https://www.cnblogs.com/leigepython/p/12144766.html" target="_blank" rel="noopener">nginx实现高并发的原理</a></p>
<p><a href="https://www.jianshu.com/p/565217337247" target="_blank" rel="noopener">FastCGI</a></p>
<p><a href="https://blog.csdn.net/wm_1991/article/details/51916027" target="_blank" rel="noopener">sendfile原理，实现文件传输性能的提升</a></p>
<p><a href="https://blog.csdn.net/god_for/article/details/44950305" target="_blank" rel="noopener">sendfile()对Nginx性能的提升</a></p>
<p><a href="http://www.360doc.com/content/18/0512/20/36367108_753420333.shtml" target="_blank" rel="noopener">用户进程缓冲区和内核缓冲区</a></p>
<p><a href="https://www.cnblogs.com/maxigang/p/9041080.html" target="_blank" rel="noopener">用户态和内核态</a></p>
<p><a href="https://www.linuxjournal.com/article/6345" target="_blank" rel="noopener">Zero Copy I: User-Mode Perspective</a></p>
<p><a href="https://www.cnblogs.com/sxhlinux/p/6254396.html" target="_blank" rel="noopener">accept_mutex与性能的关系 (nginx)</a></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>算法之排序（下）</title>
    <url>/2020/02/05/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<p>前面两篇文章说了时间复杂度为O(n<sup>2</sup>)的冒泡排序、插入排序和选择排序</p>
<a id="more"></a>

<p>前面两篇文章说了时间复杂度为O(n<sup>2</sup>)的冒泡排序、插入排序和选择排序；也说了时间复杂度为O(nlogn)的归并排序和快速排序；这次来说一下时间复杂度为O(n)的桶排序、计数排序和基数排序，由于它们的时间复杂度是线性的，所以它们也叫做线性排序（Linear sort），之所以能够做到线性复杂度，是因为它们在排序的时候，不涉及元素之间的比较，同时它们的使用条件也是非常苛刻的。</p>
<p>桶排序（Bucket sort）</p>
<p>桶排序，顾名思义，用桶来对数据进行分割，桶排序是将要排序的数组分到几个有序的桶里面，然后对每个桶里面的数据进行排序，最后将所有数据依次取出，就完成了排序。</p>
<p><img src="/2020/02/05/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89/987564607b864255f81686829503abae.jpg" alt></p>
<p>来看一下它的时间复杂度，假如将n个数据 <strong>平均</strong> 分到m个桶中，每一个桶中有x=n/m个数据，每个桶使用快速排序，时间复杂度为O(xlogx)，m个桶的时间复杂度就是O(m*xlogx)，因为x=n/m，所以时间复杂度为O(nlog(n/m))，当桶的个数接近数据n时， log(n/m) 将会是一个非常小的数，时间复杂度就接近与O(n)了。</p>
<p>但是，上面用了假如两个字，因为要使用桶排序所需要的前提条件比较多，首先数据需要很容易就可以划分到m个桶中，而且每一个桶它本身就需要有先后顺序，这样桶就不需要再进行排序了。其次，我们上面把均匀两个字给加粗了，只有在桶中的数据比较平均时才可以，如果每一个桶中的数据差距是非常大的，那桶内排序的时间复杂度就不是常量级了，最极端的情况就是分到了一个桶中，那时间复杂度就变成了O(nlogn)了。</p>
<p>桶排序比较适合用在外部排序中。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p>
<p>假如有10个G的订单数据，订单金额都是正整数，要根据金额大小进行排序，而内存又比较小，无法同时装下所有的数据该怎么办？</p>
<p>用桶排序的思路就是，先扫描一遍订单，看一下大概的金额分布，假如金额都分布在1到1万，我们就可以将金额分到10个桶里，第一个桶是1~1000，依此类推，它们的顺序依次是0，1，2…9。</p>
<p>理想情况下，就是它们均匀分布在每一个桶中，然后我们在每一个桶中使用快速排序，最后将它们依次输出出来。那如果1000-2000的金额比较多的话，还是无法直接放到内存中，那就继续使用桶排序进行分割，直到全部排序完成。</p>
<hr>
<p>计数排序（Counting sort）</p>
<p>计数排序基本上属于桶排序的特殊情况，在要排序的范围不大的时候，比如有x个数据，那我们就分x个桶，每个桶内的数据都是相同的，这样我们就省下了桶内排序的时间。</p>
<p>至于为什么要叫计数，这个是跟计数排序的实现方法有关的，不过我还没有理解清楚，这里就先放下了，这个坑之后再填。</p>
<hr>
<p>基数排序（Radix sort）</p>
<p>再来一个排序问题来看，如果有十万个手机号码，要将这十万个手机号从小到大排序。如果使用前面的桶排序和计数排序，它的范围比较大，这两种算法明显都不适合。</p>
<p>现在就可以用到第三个排序方法，基数排序。在刚刚的问题里，我们可以明显的看出来，当一个号码前面的几位已经明显大于另一个号码，那后面的也就不需要比较了，也就是说我们需要将手机号排序为第一个数字从小到大排序，第一个数字相同的，按照第二个数字从小到大排序，第二个数字相同的，按照第三个，依此类推，那如何才能排列成这样呢。</p>
<p>这里我们用一个新的思路来考虑，我们先按照最后一位数字的大小来进行排序，然后再按照倒数第二位进行排序，依此类推，经过11次排序以后，就完成了对整个手机号的排序。这里需要注意一下的是，必须用稳定的排序算法来实现，如果是非稳定的排序算法，之前的排序就没有任何的意义了。</p>
<p>用几个字符串表示的话，就是这个样子的</p>
<p><img src="/2020/02/05/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89/df0cdbb73bd19a2d69a52c54d8b9fc0c.jpg" alt></p>
<p>再举一个订单的例子，对于一批订单，我们希望将它按照金额的大小排序，如果金额相同，就按照下单的时间进行排序，一样是使用这样的方法。</p>
<p><img src="/2020/02/05/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89/1381c1f3f7819ae61ab17455ed7f0b59.jpg" alt></p>
<p>那如果我们需要排序的数据并不是等长的，又该如何去处理，比如说要对单词进行排序，有的单词是五个字母，有的单词是十五个字母，那该如何处理？</p>
<p>我们可以把所有的字母都补到一样的长度，不足的后面补0，因为根据ASCII码我们可以发现，所有的字母都在数字0之后，它并不会影响排序的正常进行，所以依旧可以使用基数排序来进行。</p>
<hr>
<p>参考文档</p>
<p>极客时间-数据结构与算法之美</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法之排序（中）-c语言实现</title>
    <url>/2020/02/04/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%AD%EF%BC%89-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>上一篇文章里说了归并排序和快速排序，它们的代码实现是非常相似的，只要理解了其中的具体实现，还是比较容易写出代码的。</p>
<a id="more"></a>

<p>归并排序</p>
<p>代码如下，需要下载代码的请移步至文末</p>
<p><img src="/2020/02/04/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%AD%EF%BC%89-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/carbon-6.png" alt></p>
<hr>
<p>快速排序</p>
<p>代码如下，需要下载代码的请移步至文末</p>
<p><img src="/2020/02/04/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%AD%EF%BC%89-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/carbon-1-2.png" alt></p>
<hr>
<p>代码：</p>
<p>归并排序：<a href="https://github.com/veselwuxin/code.seclibs.com/blob/master/c/Merge_Sort.c" target="_blank" rel="noopener">GitHub</a></p>
<p>快速排序：<a href="https://github.com/veselwuxin/code.seclibs.com/blob/master/c/Quick_Sort.c" target="_blank" rel="noopener">GitHub</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>算法之排序（中）</title>
    <url>/2020/02/04/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
    <content><![CDATA[<p>上一篇文章说了时间复杂度为O(n2)的冒泡、插入和选择三个排序方式</p>
<a id="more"></a>

<p>上一篇文章说了时间复杂度为O(n2)的冒泡、插入和选择三个排序方式，它们只适合在数据规模比较小的时候，接下来要说的是两个时间复杂度为 <strong>O(nlogn)</strong> 的算法， <strong>归并排序</strong> 和 <strong>快速排序</strong> ，它们比较适合在大规模数据的时候使用，相比于前面的三个算法就更加常用。</p>
<hr>
<p>首先来看 <strong>归并排序</strong>（Merge Sort）</p>
<p>归并排序的操作还是比较简单的，它是将数组从中间分割为前后两部分，然后再将每一部分分割，直到分割到不能分为止，然后将数值两两排序合并，不断合并到最初的数组，就完成了排序的操作，它的示例图是这样的</p>
<p><img src="/2020/02/04/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%AD%EF%BC%89/db7f892d3355ef74da9cd64aa926dc2b.jpg" alt></p>
<p>归并排序使用的是分治思想，分而治之，也就是将大问题不断的分解，分解成一个个小问题，小问题都解决了，那大问题也就都解决了，这个跟前面说的递归是特别像的，分治是一种处理问题的思想，递归是具体的技巧，分治算法一般都是用递归来实现的。</p>
<p>既然是使用递归来实现的，那我们就要找到它的通用递归公式和递归终止条件，首先我们假设第一个数值用p表示，最后一个数值用r表示，既然要将数组从中间分割，那每次分割的下标就为q=(p+r)/2，即数组就分为了两段(p,q)和(q+1,r)。</p>
<p>那递归终止条件又该怎么定义？我们来看什么时候是我们需要截至的，当数组分解成单个字符的时候就停止了，那这个时候开始结束符号将一致，所以只需要在p&gt;=r时结束就可以了。</p>
<p>分解结束之后就需要返回进行合并了，这个时候我们可以使用两个变量来帮助我们进行识别，这里用i和j两个变量来进行说明，将i和j分别指向(p,q)和(q+1,r)的第一个元素，同时比较这两个元素的大小，如果a[i]&lt;a[j]，就将a[i]放到一个临时数组中，并将i后移一位；否则就将a[j]放到临时数组中，并将j后移一位，最后将临时数组拷贝回我们的数组就完成了排序操作。</p>
<p>说了这么多理解起来也比较困难，有一句话就很符合现在的情况，Talk is cheap. Show me the code（ 不要多BB,放码过来吧 ），代码在后一片文章在给出来。</p>
<p>那归并排序是不是原地排序算法呢，由于归并排序在每次合并数据的时候都需要额外申请一个空间来存放，在合并完成之后将会被释放掉，并且在任意时刻，CPU只会有一个函数在执行，也就只有一个临时的内存空间在使用，临时空间最大也超不过数据总和n，所以空间复杂度为O(n)， <strong>不是一个原地排序算法</strong> 。</p>
<p>在合并过程中，如果(p,q)、(q+1,r)中存在相同的元素，那我们就可以先把(p,q)中的元素先放入到临时空间中，所以归并排序 <strong>是一个稳定的排序算法</strong> 。</p>
<hr>
<p>接下来，我们来看快速排序（Quicksort），简称“快排”，它也是利用分治思想，虽然看起来跟归并排序有点像，但是它们的思路是完全不一样的。</p>
<p>快速排序是在p到r中任意选择一个pivot（分区点），然后遍历p到r的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，这样就将数组分成了三个区域，p到q-1是小于 pivot 的，q+1到r是大于 pivot 的，中间q是 pivot 。</p>
<p><img src="/2020/02/04/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%AD%EF%BC%89/4d892c3a2e08a17f16097d07ea088a81.jpg" alt></p>
<p>然后不断的分治，直到区间缩小为1，所以它的递归终止条件也是p&gt;=r。</p>
<p>在选取 pivot 的时候，一般选择最后一个数值，选择中间的数值作为 pivot 后，还需要将它移动到头或尾的位置，如果我们在进行分区的时候，不考虑空间大小的因素的话，分区操作其实是非常好写的，每一次分区都新申请两个空间，将小于 pivot 的放到一个空间，将大于 pivot 的放到另一个空间，然后再将两个空间合起来拷贝回前面的数组空间，这样的话快排就不是原地排序算法了，所以我们采取另外一种比较巧妙的办法。</p>
<p>这个操作有点类似上一篇文章中的选择排序，我们通过一个变量i，把数组分为前后两个区域，用选择排序中的叫法，前面是已排序区间，后面是未排序区间，我们每次都将未排序区间中的一个数值与 pivot 进行比较，如果小于 pivot 就将它放到已排序区间的末尾，也就是变量i所指向的位置，这个时候我们采取数组中用到的数据交换的方式，将需要调动的数据与i所指位置交换，这样涉及到的操作也就仅仅是数值交换的问题了，空间复杂度也就变成了O(1)，快速排序也就 <strong>是一个原地排序算法</strong> 了。</p>
<p>同时也因为其中直接使用了数据交换的方式，他也就改变了数据原来的顺序，也就 <strong>不是一个稳定的排序算法</strong> 了。</p>
<p><img src="/2020/02/04/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%AD%EF%BC%89/086002d67995e4769473b3f50dd96de7.jpg" alt></p>
<hr>
<p>那快速排序和归并排序的区别到底在哪里，它们在于归并排序是自下而上的，先处理子问题，然后再合并；快速排序是自上而下的，先分区，然后再处理子问题。</p>
<p><img src="/2020/02/04/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%AD%EF%BC%89/aa03ae570dace416127c9ccf9db8ac05.jpg" alt></p>
<hr>
<p>参考文档</p>
<p>极客时间-数据结构与算法之美</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法之排序（上）</title>
    <url>/2020/02/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<p>排序算法有很多种，甚至有很多都完全没有听过，我们最常见，也最经典的就是：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。</p>
<a id="more"></a>

<p>按照时间复杂度来进行划分可以将其划分为三类</p>
<ul>
<li>O(n2) ：冒泡、插入、选择；基于比较</li>
<li>O(nlogn)：快排、归并；基于比较</li>
<li>O(n)：桶、计数、基数；不基于比较</li>
</ul>
<p>这次我们来说时间复杂度为O(n2)的</p>
<p>在说具体的排序方法之前，先明确排序算法的评价标准</p>
<p>首先是排序算法的执行效率，执行效率一般从最好、最坏、平均时间复杂度上分析，其分析时间复杂度时需要考虑系数、常数和低阶，因为时间复杂度是在数据规模特别大的时候的增长趋势，在平时的代码中，数量级都是比较小的，所以还需要考虑这些问题。在基于比较的排序算法中，数值比较的次数和数据的移动次数也都是需要考虑进去的。</p>
<p>其次是内存的消耗，算法的内存消耗可以用空间复杂度来表示，当空间复杂度为O(1)的算法也可以称之为原地排序算法。</p>
<p>最后是算法的稳定性，当一组数据中有两个相同的值时，排序之后两个值的顺序是如果没有交换那它就是具有稳定性的算法。</p>
<p>然后我们再引入两个概念， <strong>有序度</strong> 和 <strong>逆序度</strong></p>
<p><strong>有序度</strong> 是数组中具有有序关系的元素对的个数。</p>
<p>比如说2、4、3、1、5、6这组数组的有序度是11，因为它有11个有序元素对，分别是(2,4)、(2,3)、(2,5) (2,6)、(4,5)、(4,6)、(3,5)、(3,6)、(1,5)、(1,6)、(5,6)。</p>
<p>对于6、5、4、3、2、1这组数据，它的有序度是0；对于1、2、3、4、5、6这组数据来说，它的有序度是n*(n-1)/2，这种完全有序的数组的有序度叫做满有序度。</p>
<p>所以逆序度也就等于 <strong>满有序度-有序度</strong> ，排序的过程就是增加有序度，减少逆序度的过程，最后到达满有序度，排序就结束了。</p>
<hr>
<p><strong>冒泡排序</strong> 是依次对两个相邻的值进行比较，如果满足要求的大小关系，就继续往后看，如果不满足就将它们两个互换位置。 每一次冒泡都最起码会交换一个值 ，所以最多执行n次就可以完成排序操作。</p>
<p>如果一组数据为4、5、6、3、2、1，要求其从小到大排序，那它进行第一次冒泡排序的过程就是这样的</p>
<p><img src="/2020/02/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8A%EF%BC%89/4038f64f47975ab9f519e4f739e464e9.jpg" alt></p>
<p>这个时候，最大的数字6，就已经排在了正确的位置上，后续的冒泡操作依次是这样的</p>
<p><img src="/2020/02/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8A%EF%BC%89/9246f12cca22e5d872cbfce302ef4d09.jpg" alt></p>
<p>这种情况是刚好用了n次，如果代码直接写成循环n次的话，就可能会有多余的判断流程，如果排列顺序刚好为1、2、3、4、6、5的话，就只需要一次就可以完成排序操作，所以我们可以将每次有无数据交换的操作来作为有无完成排序的条件。</p>
<p>首先冒泡排序只交换相邻两个数据，所以空间复杂度为O(1)，是原地排序算法。</p>
<p>在冒泡排序中，我们可以规定它在两个数值相等的时候不进行交换，就可以保证排序前后相同的数值先后顺序不变，所以它是一个稳定的排序算法。</p>
<hr>
<p>在数组中，我们在中间插入一个数据的时候，是把相应位置的数据都往后挪一位，同时还可以保证顺序不变，同样的方法放到算法中，就有了 <strong>插入排序</strong> 。</p>
<p>首先是将数据分为两个区间，<strong>已排序区间</strong> 和 <strong>未排序区间</strong> ，开始的时候，已排序区间只有一个元素，然后在未排序区间中取一个元素，在已排序区间中寻找对应的位置将其插入，不断重复直到未排序区间的数据为空。</p>
<p>比如要将4、5、6、1、3、2这组数据进行排序，那过程就是这样的</p>
<p><img src="/2020/02/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8A%EF%BC%89/b60f61ec487358ac037bf2b6974d2de1.jpg" alt></p>
<p>插入排序与冒泡排序一样，有比较和移动两个操作，循环比较得到要插入的位置，然后将后面的元素往后挪一位。</p>
<p>对于不同的查找插入点方法，不管是从头到尾，还是从尾到头，元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。</p>
<p>还是拿刚刚的例子说，满有序度是n*(n-1)/2=15，初始序列的有序度是5，所以逆序度是10。</p>
<p><img src="/2020/02/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8A%EF%BC%89/fd6582d5e5927173ee35d7cc74d9c401.jpg" alt></p>
<p>在插入排序的时候，我们并不需要额外的空间，所以空间复杂度是O(1)，所以它是一个原地排序算法。</p>
<p>因为在插入的时候，我们可以让未排序区间的元素排在已排序区间中相同元素的后面，所以它也是一个稳定的排序算法。</p>
<hr>
<p><strong>选择排序</strong> 和插入排序比较类似，也有已排序区间和未排序区间，但是初始的时候是不对其进行区分的，选择排序每次都会在未排序区间中选择最小的一个数，将它放到已排序区间的末尾，如果没有已排序区间就将其放到未排序区间的前面。</p>
<p><img src="/2020/02/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8A%EF%BC%89/32371475a0b08f0db9861d102474181d.jpg" alt></p>
<p>首先选择排序也不需要申请多余的内存空间，空间复杂度为O(1)，是原地排序算法。</p>
<p>由于它将数值与前面的数值进行交换，这样将会破坏它的稳定性，所以它是一个不稳定的排序算法。</p>
<hr>
<p>相比之下，选择排序比冒泡排序和插入排序稍微逊色一点，拿冒泡排序和插入排序相比呢，从代码上看的话，冒泡排序进行数据交换是需要有第三个变量来做交换的，有三个赋值语句，而插入排序只需要一个赋值语句即可完成赋值操作，所以插入排序比冒泡排序性能更好一点。</p>
<hr>
<p>参考文档</p>
<p>极客时间-数据结构与算法之美</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>算法之排序（上）-c语言实现</title>
    <url>/2020/02/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8A%EF%BC%89-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>在上一篇文章中，我们说了时间复杂度为 O(n<sup>2</sup>)的几个排序算法</p>
<a id="more"></a>

<p>在上一篇文章中，我们说了时间复杂度为 O(n<sup>2</sup>)的几个排序算法，冒泡排序、插入排序、选择排序，在理解上和实现上都没有太难的地方，这里在实现的时候，没有再自己实现数组或链表，而是使用了c语言自带的数组进行实现的，代码中没有太难理解的地方，就直接上代码了</p>
<p>如果需要下载代码，请移步文末</p>
<p><img src="/2020/02/03/%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8A%EF%BC%89-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/carbon-5.png" alt></p>
<p>代码：<a href="https://github.com/veselwuxin/code.seclibs.com/blob/master/c/Bubble_Insertion_Selection_Sort.c" target="_blank" rel="noopener">GitHub</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>算法之递归-c语言实现</title>
    <url>/2020/02/02/%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>在上一篇文章里说了递归，这里就使用其中的上楼梯问题来进行代码实现</p>
<a id="more"></a>

<p>在上一篇文章里说了递归，这里就使用其中的上楼梯问题来进行代码实现，在上一篇文章里也说过了中间会有重复计算的情况，这里我们使用一维动态数组来进行存储，一维数组的索引值就与楼梯层数相同，可以更加清晰的理解其中的含义，代码如下</p>
<p>如果需要下载代码，请移步至文末</p>
<p><img src="/2020/02/02/%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/carbon-2-2.png" alt></p>
<p>代码：<a href="https://github.com/veselwuxin/code.seclibs.com/blob/master/c/Recursion.c" target="_blank" rel="noopener">GitHub</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>算法之递归</title>
    <url>/2020/02/02/%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p>递归是一种应用非常广泛的算法，在很多的数据结构和算法的编码中都会用到，理解递归是非常重要的。</p>
<a id="more"></a>

<p>递归在平时的生活中也是非常常用的，当你排队的时候需要知道自己排在第几个位置，而前面的人又比较多，你不能自己数出来，就可以询问你前一个人他的位置，在他的位置基础上加一便是你的位置，那如果他也不知道他的位置呢，就可以用同样的方法，继续向前询问，直到第一个人，第一个人就不用往前问了，他直到自己是第一个，这个过程就是一个递归的过程。</p>
<p>去问的时候叫做“递”，返回来的时候叫做“归”，假设自己是第n排，求自己位置的函数为f(n)，f(n-1)就是前一个人的位置，我们的位置就是f(n-1)+1，同样前一个人的位置也可以用这个公式来计算， 直到第一个人f(1)=1，这一整套流程便是递归的实际利用，编写成代码如下</p>
<p><img src="/2020/02/02/%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92/carbon-4.png" alt></p>
<p>在编写递归代码的时候，有两点必要的条件：</p>
<ul>
<li>一个问题可以分解为多个结构相同，规模不同的子问题。</li>
<li>存在终止条件。</li>
</ul>
<p>如果结构不同，那就不能构造递归了；如果不存在终止条件的话，将会无限循环，看上面的那个例子，它的终止条件就是执行到第一个人的时候，开始往后返回。</p>
<hr>
<p>递归就这样完成了，上面这个例子是只有一个递归调用的分支，还是比较好理解的，如果有多个递归分支的话，单纯靠人脑是很难理解清楚的，计算机比较适合做重复的工作，我们如果一环一环往递归里走的话，很快就迷糊了，唯一的方法就是自己屏蔽掉其中细节，只把握好第一个递归公式的构造和终止条件的判断，就能更好的理解清楚递归了。</p>
<p>假如有n阶台阶，可以每次走一个台阶或两个台阶，请问走完n阶楼梯有多少种走法？</p>
<ul>
<li>如果有一层台阶，(1)，有一种.</li>
<li>如果有两层台阶，(1,1)、(2)，有两种</li>
<li>如果有三层台阶，(1,1,1)、(1,2)、(2,1)，有三种</li>
<li>如果有四层台阶 ，(1,1,1,1)、(1,1,2)、(1,2,1)、(2,1,1)、(2,2)，有五种</li>
<li>如果有五层台阶 ，(1,1,1,1,1)、(1,1,1,2)、(1,1,2,1)、(1,2,1,1)、(2,1,1,1)、(1,2,2)、(2,1,2)、(2,2,1)，有八种</li>
<li>以此类推</li>
</ul>
<p>举几个例子，就可以很明显的发现，从第三层开始，每一层都是前两层的次数相加，所以我们就可以得到公式f(n) = f(n-1)+f(n-2) ，通过举例子是最容易理解的一个方式，实际上去理解的方法有很多种，可以自己去尝试，你可以用递归的想法去一层层跑一下，就会发现整体的困难程度是非常大的。</p>
<p>所以将其转换为代码就如下图所示</p>
<p><img src="/2020/02/02/%E7%AE%97%E6%B3%95%E4%B9%8B%E9%80%92%E5%BD%92/carbon-1-1.png" alt></p>
<hr>
<p>在写递归代码的时候，还需要注意两个问题：</p>
<ul>
<li>警惕堆栈溢出</li>
<li>警惕重复计算</li>
</ul>
<p>先说堆栈溢出，在函数调用时，会使用栈来保存临时变量，每进行一次函数调用，就会将临时变量封装后压入内存栈，这个栈的大小是由系统来决定的，如果递归太深，压入栈中的数据是非常多的，就会有堆栈溢出的风险；解决办法就是在递归函数中加入一个判断条件，来判断递归的深度，如果达到了某一个值，就直接返回报错。</p>
<p>另一个就是重复计算，当我们在计算f(5)的时候会计算f(4)和f(3)，在计算f(4)的时候还需要计算f(3)，f(3)就被重复计算了，为了避免重复计算，可以通过数据结构来记录已经计算过的值，在计算前先进行判断，如果计算过就直接将值返回。</p>
<p>为了避免这些情况，也可以将递归代码改为迭代循环的非递归方式，就是使用循环的方式来进行处理。</p>
<hr>
<p>参考文档</p>
<p>极客时间-数据结构与算法之美</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之顺序队列、链式队列、循环队列-c语言实现</title>
    <url>/2020/02/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E3%80%81%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>在上一篇文章里，说了队列的相关内容，其中除了这篇文章说的顺序队列、链式队列和循环队列三个，还提到了阻塞队列和并发队列，这两个因为能力原因，还没能实现，这个坑等以后再来补。</p>
<a id="more"></a>

<p>回来说这次实现的三个队列，首先是顺序队列，顺序队列是基于数组来实现的队列，在原数组的实现基础上增加了head和tail两个结构体成员，用来标识队头和队尾。</p>
<p><img src="/2020/02/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E3%80%81%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/carbon-2.png" alt></p>
<p>其他的也没有什么太大的变化了，代码如下</p>
<p>如果需要下载代码的，请移步文末</p>
<p><img src="/2020/02/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E3%80%81%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/carbon.png" alt></p>
<hr>
<p>接下来说链式队列，链式队列的实现与之前的实现都有一点区别，因为链表和队列两个都是需要指针的，所以在这里定义两个结构体的时候需要格外的注意一下，在后面的代码实现中也需要着重理解一下其中的含义。</p>
<p>在定义结构体的时候，我使用了typedef struct和struct两种，可以在代码中去感受一下它们的区别所在。</p>
<p><img src="/2020/02/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E3%80%81%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/carbon-1.png" alt></p>
<p>因为其中有链表的存在，所以在出队的时候需要注意将出队元素的内存空间释放掉，其他的也就没有太多了变化了，代码如下</p>
<p>如果需要下载代码，请移步至文末</p>
<p><img src="/2020/02/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E3%80%81%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/carbon-2-1.png" alt></p>
<hr>
<p>最后说循环队列，循环队列实现的难易程度与顺序队列相仿，难点在于当队列放满一次时，如何将变量回到0，从新开始走，这里还是用到前一篇文章中确定队列满时的公式，当head增加到最大时，如何返回0，head=(head+1)%size，自己可以好好琢磨一下，其他的也都是一样的方式。</p>
<p>代码如下，可以自己去好好琢磨一下</p>
<p>如果需要下载代码的，请移步至文末</p>
<p><img src="/2020/02/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E3%80%81%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/carbon-3.png" alt></p>
<hr>
<p>代码：</p>
<p>顺序队列：<a href="https://github.com/veselwuxin/code.seclibs.com/blob/master/c/array_Queue.c" target="_blank" rel="noopener">GitHub</a></p>
<p>链式队列：<a href="https://github.com/veselwuxin/code.seclibs.com/blob/master/c/Linked_Queue.c" target="_blank" rel="noopener">GitHub</a></p>
<p>循环队列：<a href="https://github.com/veselwuxin/code.seclibs.com/blob/master/c/Circular_Queue.c" target="_blank" rel="noopener">GitHub</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之队列</title>
    <url>/2020/01/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>上一篇文章说了一种“功能受限”的顺序表——栈，现在再来说一个 “功能受限”的顺序表 —— <strong>队列</strong>（queue）。</p>
<a id="more"></a>

<p>队列也是一个常用的数据结构，在大部分资源有限的情况下，当没有空闲资源的时候，基本上都是使用队列这种数据结构来实现请求排队的。</p>
<p>队列，顾名思义，就是排的一条队，比如在买票的时候排的一条队伍，先来的先买，后来的后买，不允许插队，也就是先进先出的方式，栈是后进先出的方式。</p>
<p>栈支持入栈（push）和出栈（pop）两种操作，队列也是类似的，支持入队（enqueue）和出队（dequeue）两种操作，入队就是在尾部追加一个数据，出队就是在头部取走一个数据。</p>
<p><img src="/2020/01/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/9eca53f9b557b1213c5d94b94e9dce3e.jpg" alt></p>
<p>队列作为一种非常基础的数据结构，应用是非常广泛的，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。</p>
<hr>
<p>队列在实现上跟栈也是类似的，可以使用数组或链表来进行实现，使用数组实现的叫做顺序队列，使用链表实现的叫做链式队列。但是栈只需要一个栈顶指针top就可以了，队列则需要头部head指针和尾部tail指针两个来标识。</p>
<p>比如说a、b、c、d四个数据入队以后，head指针将指向下标为0的位置，tail指针指向下标为4的位置</p>
<p><img src="/2020/01/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/5c0ec42eb797e8a7d48c9dbe89dc93cb.jpg" alt></p>
<p>当进行两次出队的操作后，head指针将指向下标为2的位置</p>
<p><img src="/2020/01/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/dea27f2c505dd8d0b6b86e262d03430d.jpg" alt></p>
<p>那如果不断的往后走，一直到下标为7后，不能再继续增加了怎么办，那就可以使用数组实现时的数据移动的方式，将数据向前迁移，那如果每进行一次出栈就迁移一次，那不就相当于一直在删除下标为0的元素，然后将整个队列都拷贝一边，操作的时间复杂度就为O(n)了呀，其实完全可以用另一种思路，在每次出栈的时候不进行迁移数据的操作，而是在数据入栈的时候，发现没有位置了，再将所有的数据向前迁移，这样时间复杂度就变成了O(1)，即队列未满时，直接入队，时间复杂度为O(1)，当队列已满时，也就是tail=n时，时间复杂度变为了O(n)，如果将最后一次的n次迁移，平均到前面的n-1次上，那它们的均摊时间复杂度就变为了O(1)。</p>
<p>上面说的是顺序队列，对于链式队列来说，就更加容易了，因为不会涉及到队满的情况了，只需要处理好指针的移动问题就可以了。</p>
<p>但是它还有一个比较严重的问题，因为它的长度是可以无限长的，所以当请求的任务特别多时，后面的任务将会等待相当长的时间，这对于对时间比较敏感的系统来说，是会出问题的。</p>
<p>顺序队列因为大小有限，如果请求的任务超过了队列长度，将会直接将后续的任务拒绝掉，这对于对时间比较敏感的系统来说，是比较合理的方式，但是如何设置队列的大小又是一个问题，队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。</p>
<hr>
<p>前面顺序队列的实现时，当tail=n时，会有大量数据迁移的操作，如果使用循环队列就可以完美的解决这个问题了。</p>
<p>循环队列，顾名思义，就是将队列的首尾相连，组成环状</p>
<p><img src="/2020/01/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/58ba37bb4102b87d66dffe7148b0f990.jpg" alt></p>
<p>就拿上图来说，这个循环队列n=8，当前head=4，tail=7，当我们再插入一个数据的时候，会插入到下标为7的位置，tail将会向后挪一个，到达了0的位置，再插入数据，依旧像上面说的一样执行，tail将指向了下标为1的地方。</p>
<p>通过这样的方法，就节省了很多数据迁移的操作，但是在代码实现上就会更加的复杂，其中最关键的地方还是确定好队空和队满的判定条件。</p>
<p>队列为空的条件仍然是head=tail，那什么情况下是队满呢？</p>
<p>在一般情况下，很明显的可以看出来，当tail+1=head的时候，即为队满</p>
<p><img src="/2020/01/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/20200201205753.png" alt></p>
<p>但是还有一个情况比较特殊，并不适用这个规则，就是当head=0，tail=7时，此时再插入一个数据的时候，观察图可以发现，此时tail将等于head，但是tail=head的时候，是我们所说的队列为空的时候，这也就是为什么循环队列会浪费一个数组空间的原因；这个情况明显已经属于队满的情况了，如果套用上面的公式，tail+1=8，head=0，并不满足我们前面所提到的常规情况。</p>
<p><img src="/2020/01/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/20200201205726.png" alt></p>
<p>那么如何才能将tail+1在最大的情况下等于0呢，这里可以引入取余的方法。当tail=7时，tail+1=8，将它与n=8取余，8%8=0，就可以满足这个要求了，通用的公式就变成了 <strong>(tail+1)%n=head</strong> ，那一般情况满不满足这个公式呢，因为在一般情况下，tail+1都是小于n的，只有在上面所说的特殊情况时tail+1=n，所以不管怎么取余都是tail+1本身，也就是等于head了，所以队满的条件为 <strong>(tail+1)%n=head</strong> 。</p>
<p>上面在解释的时候也说了循环队列会浪费一个数组空间的原因，那如果我们专门用一个记录队列大小的值size，当这个值与数组大小相等时，表示队列已满，当tail达到最底时，size不等于数组大小时，tail就指向数组第一个位置。当出队时，size–，入队时size++。</p>
<p>这种的记录方法跟之前实现栈时候的思路类似，但是这样依旧会新创建一个内存空间来存放size值，最后消耗的大小是一样的。</p>
<hr>
<p>到这里基础的队列就说完了，但是这样基础的队列在实际的业务开发中都不大会直接用到，常用的是一些比较特殊的队列，比如阻塞队列和并发队列。</p>
<p>阻塞队列其实就是在正常的队列操作中加上了阻塞操作，当队列为空时，在对头取数据的时候，会被阻塞，因为队列中还没有任何可以取的数据，直到队列中有数据时，才会取出数据并返回；如果队列已经满了，那插入数据将会被阻塞，直到有空闲位置后，将数据插入才会返回。</p>
<p>通过阻塞队列，很轻松就可以实现“生产者 – 消费者模型”，它可以有效的协调生产与消费的速度，当生产过快的时候，队列就无法再加入了，生产者就会被阻塞，直到出现空余位置的时候才会继续生产。</p>
<p><img src="/2020/01/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/5ef3326181907dea0964f612890185eb.jpg" alt></p>
<p>那我们设想一个场景，如果消费者方面已经不需要这个东西了，那生产方还是在不断的往进放东西，这样就会造成极大的浪费，这样的情况让我想起了我们现在全面深化改革的一点——供给侧结构性改革，不再让供给方无限的供给了，要在可能快出现问题的时候，便让供给方减少供给，以便让资源得到更好的利用。</p>
<p>插了点题外话，我们继续说阻塞队列，为了让数据更加高效的处理，我们还可以协调供给者和消费者的的数量。</p>
<p><img src="/2020/01/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97/9f539cc0f1edc20e7fa6559193898067.jpg" alt></p>
<p>那并发队列又是什么，并发队列就是在多线程的情况下，由于有多个线程同时操作，可能会存在一些安全问题，为了实现线程安全的队列就是并发队列，与阻塞队列类似，并发队列就是在入队和出队上加锁，同一时刻仅允许一个存或取的操作，但是锁粒度大并发度就会比较低，这个也是一个需要协调的东西。</p>
<p>实际上，基于数组的循环队列，利用 CAS 原子操作 (Compare &amp; Set，或是 Compare &amp; Swap)，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</p>
<hr>
<p>参考文档</p>
<p>极客时间-数据结构与算法之美</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之栈-c语言实现</title>
    <url>/2020/01/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>在上一篇文章中说过，栈在实现上分为顺序栈和链式栈两种。</p>
<a id="more"></a>

<p>顺序栈： 用数组实现的栈</p>
<p>链式栈： 用链表实现的栈</p>
<p>因为栈就是一种“功能受限”的顺序表，所以在实现的时候，在之前数组和链表的基础上进行修改即可达到效果。</p>
<p>顺序栈</p>
<p>在实现顺序栈的时候，为了更好的表示栈顶元素top，我将之前数组中的使用个数used替换为top，在其他方面并没有太大的变化。</p>
<p>需要下载代码请移步至文末。</p>
<p><img src="/2020/01/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/carbon-5.png" alt></p>
<p>链式栈</p>
<p>链式栈在原先链表的基础上省去了不少内容，像按位置插入，删除指定内容等，这些都是由于栈的特性决定了只能从一端进行插入和删除，也正是因为如此，所以在单链表的基础上进行修改的，使用双链表没有太大的意义。</p>
<p>需要下载代码请移步至文末。</p>
<p><img src="/2020/01/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/carbon-1-5.png" alt></p>
<p>代码：</p>
<p>顺序栈：<a href="https://github.com/veselwuxin/code.seclibs.com/blob/master/c/array%20Stack.c" target="_blank" rel="noopener">GitHub</a></p>
<p>链式栈：<a href="https://github.com/veselwuxin/code.seclibs.com/blob/master/c/Linked%20list%20Stack.c" target="_blank" rel="noopener">GitHub</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之循环链表-c语言实现</title>
    <url>/2020/01/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>之前在链表那一节说了单链表、双向链表和循环链表，前面已经把单链表和双向链表用代码实现过了，当时没有实现循环链表是在实现的过程中有一点没有想明白，今天在实现栈的时候突然相通了，就把这两条给补上。</p>
<a id="more"></a>

<p>循环链表有两种实现方式，<strong>循环单链表和循环双向链表</strong></p>
<p>因为在前面的实现过程中，我的考虑不是很全面，导致后面在它们的基础上进行修改的时候出现了很多问题，在循环链表的实现当中，我在几乎每一个函数前面都加了一条语句 <strong>struct link* x = list;</strong> 为了将链表头结点的内存地址给保留下来，在前面的实现当中，为了保证插入数据的时候在末尾插入，我将list的值进行了移动，导致现在需要头结点的内存地址时没有任何的保留了。</p>
<p>如果需要下载代码请移步至文末</p>
<p>循环单链表</p>
<p><img src="/2020/01/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/86cb7dc331ea958b0a108b911f38d155-1.jpg" alt></p>
<p><img src="/2020/01/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/carbon-6.png" alt></p>
<p>循环双向链表</p>
<p><img src="/2020/01/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/d1665043b283ecdf79b157cfc9e5ed91.jpg" alt></p>
<p><img src="/2020/01/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/carbon-1-6.png" alt></p>
<p>代码：</p>
<p>循环单链表：<a href="https://github.com/veselwuxin/code.seclibs.com/blob/master/c/Circular%20single%20linked%20list.c" target="_blank" rel="noopener">GitHub</a></p>
<p>循环双向链表：<a href="https://github.com/veselwuxin/code.seclibs.com/blob/master/c/Circular%20doubly%20linked%20list.c" target="_blank" rel="noopener">GitHub</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之栈</title>
    <url>/2020/01/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88/</url>
    <content><![CDATA[<p>前面说完了数组和列表两个常用的数据结构，虽然它们的实现代码还很粗糙，但是不妨碍自己对数据结构的深入理解，接下来就说一说<strong>栈(stack)</strong></p>
<a id="more"></a>

<p>栈，可以用一个很常见的事物来说明，比如我们放了一摞盘子，如果我们想取走下面的某一个盘子，就必须先将上面的盘子挨个移走才可以，跟小时候玩的汉诺塔益智游戏是一样的结构， 也就是后放上去的先拿出来，先放进去的后拿出来。</p>
<p>从栈的特性上来看，栈是一种受限制的线性表，它只允许在一端进行插入和删除操作，在功能实现上完全可以用数组和链表来代替，但是栈也有它自己的好处，因为只允许在一端进行插入和删除，它所暴露的操作接口就比数组和链表少很多，也就更加安全，牺牲了灵活性而增加了安全性。</p>
<p>对于栈来说，需要进行的操作只有两种，入栈和出栈，即在栈顶进行插入和删除操作，它们所涉及到的数据变化是个别数据的操作，而且入栈和出栈也就只有对栈顶元素操作时的几个临时变量，所以它的时间复杂度和空间复杂度均为O(1)。</p>
<p>在代码实现上，它既可以使用数组来实现，也可以使用链表来实现，用数组实现的栈，我们叫作顺序栈，用链表实现的栈，我们叫作链式栈。</p>
<p>这里还会涉及到的一个方法就是如何对栈进行<strong>动态扩容</strong>，对于链式栈来说，虽然不存在受固定大小的限制，但是大量的next指针，对内存的消耗也是比较巨大的。</p>
<p>动态扩容就是在空间不够时，重新创建一块比当前内存空间大的空间，然后将所有的数据都拷贝过去，这样就实现了动态扩容，一般新创建的内存空间的大小都是之前空间大小的0.5倍或1倍。</p>
<p>大致的过程如下图所示</p>
<p><img src="/2020/01/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88/b193adf5db4356d8ab35a1d32142b3da-1024x739.jpg" alt></p>
<p>在对于栈的理解当中，还要注意一点，内存中的栈与数据结构中的栈是完全不同的两个概念，需要特别注意一下</p>
<blockquote>
<p>引用自极客时间- 阿杜S考特</p>
<p>内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。<br>内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。<br>代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。<br>静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。<br>栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。<br>堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。</p>
</blockquote>
<p>对于栈的说明就这么多，接下来就是尝试对它进行代码实现。</p>
<hr>
<p>参考文档：</p>
<p>极客时间-数据结构与算法之美</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之双向链表-c语言实现</title>
    <url>/2020/01/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>这次完成了双向链表的代码实现，同时也发现了一处单链表中同样存在的错误，如果有兴趣可以回去再研究一下。</p>
<a id="more"></a>

<p>双向链表相对于单链表来说，复杂之处在于对数据的插入和删除操作时，如何处理指针的指向关系，这个时候画图来帮助理解是一个非常好的方式。</p>
<p>以下为双向链表的具体实现，需要下载代码请移步至文末</p>
<p><img src="/2020/01/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/carbon-3-1.png" alt></p>
<p>代码：<a href="https://github.com/veselwuxin/code.seclibs.com/blob/master/c/Doubly%20linked%20list.c" target="_blank" rel="noopener">GitHub</a></p>
<hr>
<p><strong>2020/1/31更新</strong></p>
<p>文中代码有些许错误，请查看最新代码</p>
<p>代码：<a href="https://github.com/veselwuxin/code.seclibs.com/blob/master/c/Doubly%20linked%20list.c" target="_blank" rel="noopener">GitHub</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之单链表-c语言实现</title>
    <url>/2020/01/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>常用的链表有单链表、双向链表和循环链表，这次只完成了单链表的c语言实现，在写代码中所遇到的问题在代码注释中也都有标注，在实现上最关键的还是对整体结构的理解，只有对整体结构有一定的了解，才能在具体的代码实现中少走很多的弯路，在具体的代码实现过程中，要着重关注每一个变量的内容和具体的含义，只有搞清楚了这一点才能在实现的时候不出现一些莫名其妙的问题。</p>
<a id="more"></a>

<p>比如在这次实现中，就碰到了在插入初始插入数据的时候，输出的内容一直与插入时相反，也就是说，起初预想的是每次插入数据都是在最后一位进行插入，而实际情况是从开头进行插入的，在仔细研究完代码后，发现了问题所在</p>
<p><img src="/2020/01/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/carbon-3.png" alt></p>
<p>我们在第一次插入数据的时候，情况是这样的</p>
<p><img src="/2020/01/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/20200128215646.png" alt></p>
<p>但是如果再继续往后面插入的时候，由于list所指的内存地址并没有改变，所以插入的情况是这样的</p>
<p><img src="/2020/01/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/20200128220328.png" alt></p>
<p>就造成了输出与输入呈倒序的方式，所以只需要将list所指向的内存地址进行变化就可以了，修改后的代码如下</p>
<p><img src="/2020/01/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/carbon-1-3.png" alt></p>
<p>所以对每个变量所代表的含义要特别清楚才能在代码实现的时候更加的清晰。</p>
<p>整体代码如下，如果需要下载代码请移步到文末</p>
<p><img src="/2020/01/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/carbon-2-2.png" alt></p>
<p>代码：<a href="https://github.com/veselwuxin/code.seclibs.com/blob/master/c/Single%20Linked%20list.c" target="_blank" rel="noopener">GitHub</a></p>
<hr>
<p><strong>2020/1/29更新</strong></p>
<p>在文章发出之后，有收到朋友对代码的批评</p>
<p><img src="/2020/01/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8D%95%E9%93%BE%E8%A1%A8-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/Untitled-2.png" alt></p>
<p>这里我确实要说一下对不起了，自己对c语言确实没有完全的了解，现在也是在借助学数据结构的过程练一练代码，在学校学的c语言本就c不c，c++不c++的，在之后的运用当中，我尽力去避免这些错误的出现，希望大家可以多多帮助，多多提问题。</p>
<p>我已对这两处问题进行修改，代码如下</p>
<p>代码：<a href="https://github.com/veselwuxin/code.seclibs.com/blob/master/c/Single%20Linked%20list.c" target="_blank" rel="noopener">GitHub</a></p>
<hr>
<p><strong>2020/1/31更新</strong></p>
<p>继续对代码进行了修改，请查看最新链接</p>
<p>代码：<a href="https://github.com/veselwuxin/code.seclibs.com/blob/master/c/Single%20Linked%20list.c" target="_blank" rel="noopener">GitHub</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之链表</title>
    <url>/2020/01/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>前面讲了数据结构中最常用、最基础的数组，接下来说一说数据结构中另一个比较基础比较常用的数据结构——链表，相比于数组来说，链表更为复杂一点，在理解和实现上都比较困难。</p>
<a id="more"></a>

<p>首先数组必须是一段连续的内存空间来进行存储的，即使剩余的内存碎片整合在一起大于所需要的内存也是不能申请成功的，而链表则不然，它不需要连续的内存空间，而是靠“指针”将不连续的内存空间都连接到一起，如果数组储存一个数据需要一个空间，那单链表就需要两个，注意是单链表，一个用来存数据，一个用来存下一块内存空间的地址，具体表现如下图所示</p>
<p><img src="/2020/01/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/d5d5bee4be28326ba3c28373808a62cd.jpg" alt></p>
<p>上面说数组和链表所占空间的大小的时候，专门说了是单链表，因为我们常用的链表形式有单链表、双向链表和循环链表等，单链表是其中最简单、最常见的一个。</p>
<p>如下图就是单链表的结构图，每一块我们都将它称为一个结点，在需要说明当前结点的后一个结点时，我们常称为当前结点的后继结点，其中date区域是用来存放数据的，next区域是存放指针指向下一块内存空间的，我们将它称为后继指针next。</p>
<p><img src="/2020/01/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/b93e7ade9bb927baad1348d9a806ddeb.jpg" alt></p>
<p>在图中可以看出来，第一个和最后一个结点是比较特殊的，第一个结点也叫做头结点，它存储的是整个链表的首地址，也叫做基地址，有了首地址，我们就可以遍历出来整个链表中所有的元素；最后一个结点也叫做尾结点，它是没有后继结点的，所以它的后继指针next存放的是NULL，用来表示链表已经结束了。</p>
<p>与数组一样，链表也支持查找、插入和删除操作。但是链表进行插入和删除操作是非常的高效的，对于数组来说，它需要有连续的内存空间，所以每次插入和删除都需要大量的数据移动操作，而链表本身就不需要连续的内存空间，所以插入和删除的时候，只需要更改next的指向，就可以完成插入和删除操作了，它所对应的时间复杂度为O(1)。</p>
<p><img src="/2020/01/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/452e943788bdeea462d364389bd08a17.jpg" alt></p>
<p>但是有利就有弊，数组因为内存空间连续，所以支持随机访问，知道首地址、数据长度和索引，便可以计算出内存地址，但是在插入和删除的时候就会有大量的数据移动操作；链表恰恰相反，因为内存空间不连续，所以在插入和删除的时候，只需要更改后继指针next就可以了，但是在需要访问指定位置的数据内容时，就需要从头结点开始遍历，一直到所需要查询的结点为止，其时间复杂度为O(n)。</p>
<p>接下来我们来看循环链表和双向链表。</p>
<p>循环链表是特殊的单链表，单链表的尾结点是指向空地址NULL的，循环链表的尾节点指向了头结点。</p>
<p><img src="/2020/01/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/86cb7dc331ea958b0a108b911f38d155.jpg" alt></p>
<p>与单链表相比，它更适合从尾结点走到头结点，对于一些环形结构的数据，循环链表就更加适合。</p>
<p>接下来说双向链表，双向链表是更加常用的一个链表结构，与单链表相比，它的date数据区域有前后两个指针，前驱指针prev和后继指针next，那么它储存一个数据所占用的空间就更大了，还是用开头的那个例子，加入数组占一个空间，那单链表就占用两个空间，双向链表就需要占用三个空间。</p>
<p><img src="/2020/01/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/cbc8ab20276e2f9312030c313a9ef70b.jpg" alt></p>
<p>虽然它占用了更多的空间，但是它也比前面的两个类型更加的灵活，双向链表在处理查询、插入和删除操作的时候，与单链表类似，但是在一些情况下，它比单链表更加的高效。</p>
<p>假如，我们要删除指定指针所指向的结点，在这个情况下，我们要删除结点的时候，首先需要知道删除结点的前驱结点，然后将前驱结点的后继指针指向删除结点的后继结点。因为单链表不能直接获取到当前结点的前驱结点，所以需要从头开始遍历，直到某一结点的next指向了删除结点，就表明那一个结点为删除结点的前驱结点，其时间复杂度为O(n)。而对于双向链表来说，便可以直接获取到删除结点的前驱结点，时间复杂度为O(1)。同样在指定结点前插入某个节点，双向链表也一样更加具有优势。</p>
<p>再假如，如果要查找的链表是一个有序链表，那么使用双向链表便可以非常轻松的使用二分法来进行查找。</p>
<hr>
<p>参考文档</p>
<p>极客时间-数据结构与算法之美</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之数组-c代码实现</title>
    <url>/2020/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84-c%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>在上一篇文章里讲了数组的具体内容，然后自己使用c语言对数组进行了实现。</p>
<a id="more"></a>

<p>其中定义了一个结构体，定义了长度、已使用长度和地址指针。</p>
<p><img src="/2020/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84-c%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/carbon-2.png" alt></p>
<p>定义alloc函数来分配内存空间</p>
<p><img src="/2020/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84-c%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/carbon-1-2.png" alt></p>
<p>之后便是插入元素的insert函数、打印数组的dump函数、搜索数组的search函数和删除数组的del函数</p>
<p>所有的操作步骤都是在main函数中提前定义好了，来进行验证前面所实现的函数</p>
<p>如果需要下载代码，请移步文章最后。</p>
<p><img src="/2020/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84-c%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/carbon-2-1.png" alt></p>
<p>运行结果如下</p>
<p><img src="/2020/01/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84-c%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/Untitled-1.png" alt></p>
<p>代码：<a href="https://github.com/veselwuxin/code.seclibs.com/blob/master/c/array.c" target="_blank" rel="noopener">GitHub</a></p>
<hr>
<p><strong>2020/1/31更新</strong></p>
<p>文中代码有些许错误，请查看最新代码</p>
<p>代码：<a href="https://github.com/veselwuxin/code.seclibs.com/blob/master/c/array.c" target="_blank" rel="noopener">GitHub</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构之数组</title>
    <url>/2020/01/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>在说数组之前咱们先明确两个概念，什么是<strong>线性表</strong>，什么是<strong>非线性表</strong></p>
<a id="more"></a>

<p>顾名思义，线性表就是把数据排成一条，每个数据只有前后两种情况，常见的线性表有<strong>数组、链表、队列、栈</strong>等</p>
<p><img src="/2020/01/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84/b6b71ec46935130dff5c4b62cf273477.jpg" alt></p>
<p>那非线性表就更好理解了，数据不是按照一条线来排列的，每个数据并不只有前后两个方向，常见的有<strong>二叉树、堆、图</strong>等</p>
<p><img src="/2020/01/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84/6ebf42641b5f98f912d36f6bf86f6569.jpg" alt></p>
<p>明白了这个概念之后，咱们再来说数组，什么是数组？</p>
<p>数组不仅是大多数编程语言中的一个数据类型，它更是一个最基础的数据结构。</p>
<p><strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</strong></p>
<p>关于线性表前面已经说过了，接下来说具有连续的内存空间、存储相同类型的数据，也正是因为这一点才使数组有了<strong>随机访问</strong>的特性。</p>
<p>我们拿下面这个例子来进行说明，有一个长度为10的int类型的数组，我们给它分配一块连续内存空间 1000～1039，内存块的首地址为1000</p>
<p><img src="/2020/01/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84/98df8e702b14096e7ee4a5141260cdc4.jpg" alt></p>
<p>当我们需要访问其中的数据的时候，计算机会先通过一个寻址公式来找到内存地址，然后再读取其中的数据。</p>
<p>在数组中我们使用的寻址公式为</p>
<p>[mark]a[i]_address = base_address + i * data_type_size[/mark]</p>
<p>base_address为内存块的首地址1000，data_type_size为数据类型的大小，这里我们使用的是int类型，所以data_type_size为4个字节，也正是这个原因，在很多语言中，都将数组的第一个下标定为0，因为在寻址的时候，可以直接得到内存地址，而不需要再将数值减一后再进行计算，虽然我们口算很简单，但是在CPU中，它所进行的运算还是相当多的。</p>
<p>当我们需要得到数组中第一个元素的内容时，便直接套公式1000+0*4=1000，便直接得到了内存地址。</p>
<p>所以数组适合查询，支持随机访问，在根据下标进行随机访问时时间复杂度为O(1)，这里需要注意一下，说数组的时间复杂度的时候一定要说明在跟进下标进行随机访问的时候，因为如果使用二分查找的话，即便已经进行过排序的数组，时间复杂度也是O(logn)。</p>
<p>但是数组的随机访问的特性有利有弊，因为数组要保证空间是连续的，所以在增加和删除的时候，就需要进行大量的操作将数据进行移动，将是非常低效的。</p>
<p>我们先来说<strong>插入操作</strong>，假如数组的长度为x，那么如果要在第y个位置插入一个数据，那么就需要将y到x的所有数据都往后挪一位，将第y个位置腾出来。</p>
<p>我们来看一下它所涉及到的时间复杂度，如果插入的数据在最后一个，就不需要进行移动，最好时间复杂度为O(1)；如果插入的数据在第一个，则后面的每一个数据都需要往后挪一个，最坏时间复杂度为O(n)；因为在每一个位置插入的概率都是一样的，所以平均时间复杂度为(1+2+…+n)/n=O(n)。</p>
<p>当然这是对数组数据是有序的情况下来说的，如果数据是无序的话，就不需要这些操作了，如果要在第y位插入数据，只需要将第y位的数据移动到整个数组的最后面，然后再将需要插入的数据插入即可，这个时候的时间复杂度就降为了O(1)。</p>
<p>接下来说<strong>删除操作</strong>，与插入数据类似，如果要删除第y位的数据，就需要将y到n的数据都往前挪一个，否则内存空间就不连续了，如果删除数组末尾的数据，最好时间复杂度为 O(1)；如果删除开头的数据，最坏时间复杂度为 O(n)，删除每一个数据的概率是相同的，平均时间复杂度为 O(n)。</p>
<p>数组到这里也就结束了，再接着就是代码实现。</p>
<hr>
<p>参考文档</p>
<p>极客时间-数据结构和算法之美</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>时间复杂度分析</title>
    <url>/2020/01/20/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>在上一篇文章中我们提到了时间复杂度大O分析法的使用，这次继续来探究时间复杂度的分析</p>
<a id="more"></a>

<p>我们先来看一下下面这段代码</p>
<p><img src="/2020/01/20/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/carbon-1.png" alt></p>
<p>这段代码的作用是在数组中寻找x的位置，找到了直接返回位置，没有找到的话返回-1，用上一篇文章所学到的知识，可以很清楚的看出来，这段代码的时间复杂度为O(n)</p>
<p>但是这段代码明显还有优化的空间，如果我们在数组中间寻找到x的话，就不需要把整个数组都循环一边了，所以可以优化为下面这段代码。</p>
<p><img src="/2020/01/20/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/carbon-1-1.png" alt></p>
<p>如果在这种情况下的话，就不能用上一次所说到的方法来衡量了，因为我们不知道需要寻找的x所在的位置在哪里，如果在第一个的话，它的时间复杂度就是O(1)，如果这个数组里没有的话，就需要全部遍历一遍，它的时间复杂度就是O(n)，这里就需要引入<strong>最好时间复杂度</strong>和<strong>最坏时间复杂度</strong></p>
<p>顾名思义，最好时间复杂度就是在最理想的状态下的时间复杂度，就是我们前面说的，所需要找的x恰好是数组的第一个字符，时间复杂度为O(1)</p>
<p>最坏时间复杂度就是在最糟糕的情况下的时间复杂度，就是前面说的需要寻找的x不在数组中的情况，时间复杂度就是O(n)</p>
<p>但是问题又来了，不管是最好还是最坏，它们发生的概率都是非常小的，都不能真正代表它的时间复杂度，这里我们就需要再引入一个概念：<strong>平均时间复杂度</strong></p>
<p>还是前面的例子，我们把x在每一个位置上所需要便利的个数都加起来然后再处以总次数n+1来求平均，这样的话我们就能够得到平均时间复杂度了</p>
<p><img src="/2020/01/20/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/d889a358b8eccc5bbb90fc16e327a22f.jpg" alt></p>
<p>这里提供一个化简的思路，使用高中所学的倒序相加法来进行化简，在化简得到这个值以后，因为在大O表示法中是可以省略系数、低阶和常量的，所以最后得到的平均时间复杂度为O(n)</p>
<p>虽然这样得到的结论是没有任何问题的，但是在计算的过程中还是有一些出入的，因为这n+1种情况出现的概率是不一样的，所以在每一个数计算的时候还需要乘上相对应的概率才可以，具体的运算情况如下</p>
<blockquote>
<p>我们知道，要查找的变量 x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便你理解，我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。</p>
<p>所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。因此，前面的推导过程中存在的最大问题就是，没有将各种情况发生的概率考虑进去。</p>
<p>如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样：</p>
<p><img src="/2020/01/20/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/36c0aabdac69032f8a43368f5e90c67f.jpg" alt></p>
<p>这个值就是概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。</p>
<p>引入概率之后，前面那段代码的加权平均值为 (3n+1)/4。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n)。</p>
</blockquote>
<p>到这里基本我们常用的时间复杂度就说完了，但是还有一种特殊的平均时间复杂度，那就是<strong>均摊时间复杂度</strong></p>
<p>均摊时间复杂度就是把耗时多的平均到耗时少的上面，一般都是不会遇到的，而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度，所以就不再过多的提它了，因为连平均时间复杂度的应用条件都是极其苛刻的，均摊时间复杂度就更是极少会碰到了，明白最好时间复杂度和最坏时间复杂度就可以了。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构与算法初步认识</title>
    <url>/2020/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/</url>
    <content><![CDATA[<p>什么是数据结构和算法</p>
<p>数据结构和算法经常是结合在一起的东西，数据结构是数据的存储方式，而算法是对数据的具体操作，他们二者是相辅相成的，数据结构是为算法服务的，算法是要作用在特定的数据结构之上的，两者是不可以孤立存在的。</p>
<a id="more"></a>

<p>在平时我们所遇到的数据结构和算法有以下一些</p>
<p><img src="/2020/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95-scaled.jpg" alt></p>
<p>整个列表的内容下来还是非常多的，这里不立什么flag，只是为了给之后所学习的内容做一个更好的铺垫。</p>
<p>数据结构和算法的应用就是为了解决程序的快和省的问题，即运行的够快，占用的空间够少，在评比这两项内容的时候，我们引入了时间复杂度和空间复杂度两个复杂度的概念。虽然说我们可以在写完程序后对程序的时间进行计算和统计等，但那属于事后统计法，有一种事后诸葛亮的感觉，我们需要的是在写程序的时候就对整体的复杂性有一个大概的评估。</p>
<p>这里我们引入的是大O表示法，T(n)=O(f(n))，其中，T(n) 表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</p>
<p>然后我们先来说时间复杂度分析，在进行分析的时候，我们只关注跟规模n有关的内容，其余的内容我们默认它们的时间复杂度为O(1)，比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a&#x3D;1;</span><br><span class="line">int b&#x3D;2;</span><br><span class="line">int c&#x3D;3;</span><br></pre></td></tr></table></figure>

<p>这类型的代码不管在程序有多少，即使是成千上万行，因为它们的数量是固定的，如果在n为无穷大的时候，它们也就可以忽略不计了，所以我们认为它们的时间复杂度为O(1)，在计算的时候就可以忽略掉这部分内容了。</p>
<p>那如果是一个简单的循环语句的话，它的时间复杂度就为O(n)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int sum &#x3D; 0;</span><br><span class="line">int i &#x3D; 1;</span><br><span class="line">for (; i &lt;&#x3D; n; ++i) &#123;</span><br><span class="line">sum &#x3D; sum + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为前面的赋值语句在后面的循环的复杂度面前就可以忽略不计了，所以只需要看循环执行的次数即可。</p>
<p>如果是多个语句结合在一起的话就需要仔细进行分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">int sum_1 &#x3D; 0;</span><br><span class="line">int p &#x3D; 1;</span><br><span class="line">for (; p &lt; 100; ++p) &#123;</span><br><span class="line">sum_1 &#x3D; sum_1 + p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sum_2 &#x3D; 0;</span><br><span class="line">int q &#x3D; 1;</span><br><span class="line">for (; q &lt; n; ++q) &#123;</span><br><span class="line">sum_2 &#x3D; sum_2 + q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sum_3 &#x3D; 0;</span><br><span class="line">int i &#x3D; 1;</span><br><span class="line">int j &#x3D; 1;</span><br><span class="line">for (; i &lt;&#x3D; n; ++i) &#123;</span><br><span class="line">j &#x3D; 1;</span><br><span class="line">for (; j &lt;&#x3D; n; ++j) &#123;</span><br><span class="line">sum_3 &#x3D; sum_3 + i * j;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return sum_1 + sum_2 + sum_3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于这样的代码，我们可以很清楚的分析出来，三段代码的时间复杂度依次是O(1)、O(n)、O(n²)，但因为它们是一个整体的存在，我们选取它们其中最大的一个时间复杂度来作为这段代码所需要的时间复杂度，即O(n²)。</p>
<p>接着我们再来看一段代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line">int i &#x3D; 1;</span><br><span class="line">for (; i &lt; n; ++i) &#123;</span><br><span class="line">ret &#x3D; ret + f(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int f(int n) &#123;</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">int i &#x3D; 1;</span><br><span class="line">for (; i &lt; n; ++i) &#123;</span><br><span class="line">sum &#x3D; sum + i;</span><br><span class="line">&#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们先看cal函数，如果把f()操作作为一个简单操作，那么它的时间复杂度为O(n)，但是f()操作本身的时间复杂度为O(n)，所以整体的时间复杂度需要将两个相乘，为O(n²)</p>
<p>紧接着在来一段类似的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i&#x3D;1;</span><br><span class="line">while (i &lt;&#x3D; n) &#123;</span><br><span class="line">i &#x3D; i * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码看起来跟刚开始说的循环没有太大的却别，但是仔细分辨一下，就会发现不同</p>
<p>如果将i从1开始循环，每次都会将i的值乘2，最后跳出循环的条件应该为2x=n (2的x次方)，只要我们求出来x的大小也就知道了这个它的时间复杂度，即O(log2n)（log以2为底，n的对数）</p>
<p>到这里，也就基本能理解时间复杂度的计算方法了</p>
<p>然后来说一下我们常见的几种时间复杂度</p>
<p><img src="/2020/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/3723793cc5c810e9d5b06bc95325bf0a.jpg" alt></p>
<p>在这些时间复杂度中，可以粗略的将它们分成两类，多项式量级和非多项式量级，非多项式量级只有图中画波浪线的两种，当数据规模n越来越大时，非多项式量级的执行时间将会急剧增加，就是我们所谓的指数级爆炸式增长，所以它们的算法是非常低效。</p>
<p>除了上面提到的几种时间复杂度外，还有一种由多个数据规模同时决定的复杂度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int cal(int m, int n) &#123;</span><br><span class="line">int sum_1 &#x3D; 0;</span><br><span class="line">int i &#x3D; 1;</span><br><span class="line">for (; i &lt; m; ++i) &#123;</span><br><span class="line">sum_1 &#x3D; sum_1 + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sum_2 &#x3D; 0;</span><br><span class="line">int j &#x3D; 1;</span><br><span class="line">for (; j &lt; n; ++j) &#123;</span><br><span class="line">sum_2 &#x3D; sum_2 + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以很容易的看出，第一个的时间复杂度为O(m)，第二个时间复杂度为O(n)，后面将两个函数的值相加，我们无法轻易的选取其中的一个时间复杂度作为整个模块的时间复杂度，所以它们的时间复杂度为O(m+n)</p>
<p>到这里时间复杂度也就基本说完了，接着说一下空间复杂度的相关内容</p>
<p>这里可以通过类比的方式来说空间复杂度，时间复杂度是执行时间和数据规模之间的增长关系，那么空间复杂度就是存储空间和数据规模之间的增长关系，我们常见到的空间复杂度也就只有 O(1)、O(n)、O(n²)三种，像 O(logn)、O(nlogn) 等一般都是用不到的，所以掌握了时间复杂度的计算方法对空间复杂度也就有大致了解了。</p>
<p><img src="/2020/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/497a3f120b7debee07dc0d03984faf04.jpg" class title="test}&lt;&#x2F;p&gt;"></p>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>公众号历史文章整理</title>
    <url>/2020/01/06/gongzhonghao_pages/</url>
    <content><![CDATA[<p>为了方便之后查看，便把之前公众号中写过的自认为还可以的文章都列到这里。</p>
<a id="more"></a>

<p>Linux相关</p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11689774.html" target="_blank" rel="noopener">Linux目录结构及开机流程详解</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11704545.html" target="_blank" rel="noopener">Linux重定向及反弹shell详解</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11717685.html" target="_blank" rel="noopener">Linux文件查找命令详解</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11746100.html" target="_blank" rel="noopener">Linux权限详解</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11782709.html" target="_blank" rel="noopener">Linux特殊权限详解</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11787157.html" target="_blank" rel="noopener">Linux定时任务简述</a></p>
<p>环境搭建</p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11591816.html" target="_blank" rel="noopener">基于docker构建测试环境</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11598181.html" target="_blank" rel="noopener">Windows server 2008 快速搭建域环境</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11698527.html" target="_blank" rel="noopener">部署IIS+PHP+Oracle环境</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11648462.html" target="_blank" rel="noopener">部署IIS+PHP+SQL server环境</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11614963.html" target="_blank" rel="noopener">composer安装依赖时报错的处理办法</a></p>
<p>web相关</p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11598721.html" target="_blank" rel="noopener">正则过滤不完整造成的储存xss</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11601369.html" target="_blank" rel="noopener">挖穿各大SRC的短信轰炸</a></p>
<p>端口转发</p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11596538.html" target="_blank" rel="noopener">使用netsh来进行端口转发</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11598876.html" target="_blank" rel="noopener">lcx端口转发</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11598941.html" target="_blank" rel="noopener">FPipe端口转发</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11599131.html" target="_blank" rel="noopener">socat在Windows下的使用</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11599231.html" target="_blank" rel="noopener">socat在Linux下的使用</a></p>
<p>内网相关</p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11599273.html" target="_blank" rel="noopener">Windows认证 | Windows本地认证</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11599406.html" target="_blank" rel="noopener">Windows认证 | 网络认证</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11601346.html" target="_blank" rel="noopener">Windows认证 | 域认证</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11601351.html" target="_blank" rel="noopener">SPN扫描</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11601357.html" target="_blank" rel="noopener">Kerberoasting攻击</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11746207.html" target="_blank" rel="noopener">离线破解Navicat密码</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11768481.html" target="_blank" rel="noopener">域渗透 | 白银票据利用</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11768517.html" target="_blank" rel="noopener">域渗透 | 白银票据防御</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11768579.html" target="_blank" rel="noopener">域渗透 | 白银票据利用实例</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11769233.html" target="_blank" rel="noopener">域渗透 | 黄金票据利用</a></p>
<p>审计相关</p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11601375.html" target="_blank" rel="noopener">代码审计之CSRF原理及修复</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11601385.html" target="_blank" rel="noopener">代码审计之XSS及修复</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11601378.html" target="_blank" rel="noopener">代码审计之SQL注入及修复</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11601390.html" target="_blank" rel="noopener">代码审计之越权及越权</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11601398.html" target="_blank" rel="noopener">代码审计之未授权访问及修复</a></p>
<p>复现相关</p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11678655.html" target="_blank" rel="noopener">Linux sudo权限提升漏洞（CVE-2019-14287）</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11746193.html" target="_blank" rel="noopener">php-fpm在nginx特定环境下的任意代码执行漏洞（CVE-2019-11043）</a></p>
<p><a href="https://www.cnblogs.com/wuxinmengyi/p/11776007.html" target="_blank" rel="noopener">Apache Solr velocity模板注入RCE漏洞复现</a></p>
]]></content>
      <categories>
        <category>公众号</category>
      </categories>
  </entry>
</search>
